/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const HAL_kInvalidHandle: u32 = 0;
pub const HAL_CAN_SEND_PERIOD_NO_REPEAT: u32 = 0;
pub const HAL_CAN_SEND_PERIOD_STOP_REPEATING: i32 = -1;
pub const HAL_CAN_IS_FRAME_REMOTE: u32 = 2147483648;
pub const HAL_CAN_IS_FRAME_11BIT: u32 = 1073741824;
pub const HAL_ERR_CANSessionMux_InvalidBuffer: i32 = -44086;
pub const HAL_ERR_CANSessionMux_MessageNotFound: i32 = -44087;
pub const HAL_WARN_CANSessionMux_NoToken: u32 = 44087;
pub const HAL_ERR_CANSessionMux_NotAllowed: i32 = -44088;
pub const HAL_ERR_CANSessionMux_NotInitialized: i32 = -44089;
pub const HAL_ERR_CANSessionMux_SessionOverrun: u32 = 44050;
pub const HAL_IO_CONFIG_DATA_SIZE: u32 = 32;
pub const HAL_SYS_STATUS_DATA_SIZE: u32 = 44;
pub const HAL_USER_STATUS_DATA_SIZE: u32 = 908;
pub const HALFRC_NetworkCommunication_DynamicType_DSEnhancedIO_Input: u32 = 17;
pub const HALFRC_NetworkCommunication_DynamicType_DSEnhancedIO_Output: u32 = 18;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Header: u32 = 19;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Extra1: u32 = 20;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Vertices1: u32 = 21;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Extra2: u32 = 22;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Vertices2: u32 = 23;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Joystick: u32 = 24;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Custom: u32 = 25;
pub const HAL_kMaxJoystickAxes: u32 = 12;
pub const HAL_kMaxJoystickPOVs: u32 = 12;
pub const HAL_kMaxJoysticks: u32 = 6;
pub const CTR_RxTimeout_MESSAGE: &[u8; 25] = b"CTRE CAN Receive Timeout\0";
pub const CTR_TxTimeout_MESSAGE: &[u8; 26] = b"CTRE CAN Transmit Timeout\0";
pub const CTR_InvalidParamValue_MESSAGE: &[u8; 27] = b"CTRE CAN Invalid Parameter\0";
pub const CTR_UnexpectedArbId_MESSAGE: &[u8; 45] =
    b"CTRE Unexpected Arbitration ID (CAN Node ID)\0";
pub const CTR_TxFailed_MESSAGE: &[u8; 24] = b"CTRE CAN Transmit Error\0";
pub const CTR_SigNotUpdated_MESSAGE: &[u8; 28] = b"CTRE CAN Signal Not Updated\0";
pub const NiFpga_Status_FifoTimeout_MESSAGE: &[u8; 27] = b"NIFPGA: FIFO timeout error\0";
pub const NiFpga_Status_TransferAborted_MESSAGE: &[u8; 31] = b"NIFPGA: Transfer aborted error\0";
pub const NiFpga_Status_MemoryFull_MESSAGE: &[u8; 46] =
    b"NIFPGA: Memory Allocation failed, memory full\0";
pub const NiFpga_Status_SoftwareFault_MESSAGE: &[u8; 34] = b"NIFPGA: Unexpected software error\0";
pub const NiFpga_Status_InvalidParameter_MESSAGE: &[u8; 26] = b"NIFPGA: Invalid Parameter\0";
pub const NiFpga_Status_ResourceNotFound_MESSAGE: &[u8; 27] = b"NIFPGA: Resource not found\0";
pub const NiFpga_Status_ResourceNotInitialized_MESSAGE: &[u8; 33] =
    b"NIFPGA: Resource not initialized\0";
pub const NiFpga_Status_HardwareFault_MESSAGE: &[u8; 23] = b"NIFPGA: Hardware Fault\0";
pub const NiFpga_Status_IrqTimeout_MESSAGE: &[u8; 26] = b"NIFPGA: Interrupt timeout\0";
pub const ERR_CANSessionMux_InvalidBuffer_MESSAGE: &[u8; 20] = b"CAN: Invalid Buffer\0";
pub const ERR_CANSessionMux_MessageNotFound_MESSAGE: &[u8; 23] = b"CAN: Message not found\0";
pub const WARN_CANSessionMux_NoToken_MESSAGE: &[u8; 14] = b"CAN: No token\0";
pub const ERR_CANSessionMux_NotAllowed_MESSAGE: &[u8; 17] = b"CAN: Not allowed\0";
pub const ERR_CANSessionMux_NotInitialized_MESSAGE: &[u8; 21] = b"CAN: Not initialized\0";
pub const ERR_FRCSystem_NetCommNotResponding_MESSAGE: &[u8; 34] =
    b"FRCSystem: NetComm not responding\0";
pub const ERR_FRCSystem_NoDSConnection_MESSAGE: &[u8; 39] =
    b"FRCSystem: No driver station connected\0";
pub const HAL_SUCCESS: u32 = 0;
pub const SAMPLE_RATE_TOO_HIGH: u32 = 1001;
pub const SAMPLE_RATE_TOO_HIGH_MESSAGE: &[u8; 43] = b"HAL: Analog module sample rate is too high\0";
pub const VOLTAGE_OUT_OF_RANGE: u32 = 1002;
pub const VOLTAGE_OUT_OF_RANGE_MESSAGE: &[u8; 60] =
    b"HAL: Voltage to convert to raw value is out of range [0; 5]\0";
pub const LOOP_TIMING_ERROR: u32 = 1004;
pub const LOOP_TIMING_ERROR_MESSAGE: &[u8; 58] =
    b"HAL: Digital module loop timing is not the expected value\0";
pub const SPI_WRITE_NO_MOSI: u32 = 1012;
pub const SPI_WRITE_NO_MOSI_MESSAGE: &[u8; 50] =
    b"HAL: Cannot write to SPI port with no MOSI output\0";
pub const SPI_READ_NO_MISO: u32 = 1013;
pub const SPI_READ_NO_MISO_MESSAGE: &[u8; 50] =
    b"HAL: Cannot read from SPI port with no MISO input\0";
pub const SPI_READ_NO_DATA: u32 = 1014;
pub const SPI_READ_NO_DATA_MESSAGE: &[u8; 40] = b"HAL: No data available to read from SPI\0";
pub const INCOMPATIBLE_STATE: u32 = 1015;
pub const INCOMPATIBLE_STATE_MESSAGE: &[u8; 59] =
    b"HAL: Incompatible State: The operation cannot be completed\0";
pub const NO_AVAILABLE_RESOURCES: i32 = -1004;
pub const NO_AVAILABLE_RESOURCES_MESSAGE: &[u8; 40] = b"HAL: No available resources to allocate\0";
pub const NULL_PARAMETER: i32 = -1005;
pub const NULL_PARAMETER_MESSAGE: &[u8; 45] = b"HAL: A pointer parameter to a method is NULL\0";
pub const ANALOG_TRIGGER_LIMIT_ORDER_ERROR: i32 = -1010;
pub const ANALOG_TRIGGER_LIMIT_ORDER_ERROR_MESSAGE: &[u8; 60] =
    b"HAL: AnalogTrigger limits error.  Lower limit > Upper Limit\0";
pub const ANALOG_TRIGGER_PULSE_OUTPUT_ERROR: i32 = -1011;
pub const ANALOG_TRIGGER_PULSE_OUTPUT_ERROR_MESSAGE: &[u8; 51] =
    b"HAL: Attempted to read AnalogTrigger pulse output.\0";
pub const PARAMETER_OUT_OF_RANGE: i32 = -1028;
pub const PARAMETER_OUT_OF_RANGE_MESSAGE: &[u8; 34] = b"HAL: A parameter is out of range.\0";
pub const RESOURCE_IS_ALLOCATED: i32 = -1029;
pub const RESOURCE_IS_ALLOCATED_MESSAGE: &[u8; 32] = b"HAL: Resource already allocated\0";
pub const RESOURCE_OUT_OF_RANGE: i32 = -1030;
pub const RESOURCE_OUT_OF_RANGE_MESSAGE: &[u8; 45] =
    b"HAL: The requested resource is out of range.\0";
pub const HAL_INVALID_ACCUMULATOR_CHANNEL: i32 = -1035;
pub const HAL_INVALID_ACCUMULATOR_CHANNEL_MESSAGE: &[u8; 55] =
    b"HAL: The requested input is not an accumulator channel\0";
pub const HAL_COUNTER_NOT_SUPPORTED: i32 = -1058;
pub const HAL_COUNTER_NOT_SUPPORTED_MESSAGE: &[u8; 51] =
    b"HAL: Counter mode not supported for encoder method\0";
pub const HAL_PWM_SCALE_ERROR: i32 = -1072;
pub const HAL_PWM_SCALE_ERROR_MESSAGE: &[u8; 44] = b"HAL: The PWM Scale Factors are out of range\0";
pub const HAL_HANDLE_ERROR: i32 = -1098;
pub const HAL_HANDLE_ERROR_MESSAGE: &[u8; 47] = b"HAL: A handle parameter was passed incorrectly\0";
pub const HAL_LED_CHANNEL_ERROR: i32 = -1099;
pub const HAL_LED_CHANNEL_ERROR_MESSAGE: &[u8; 68] =
    b"HAL: Addressable LEDs only supported on PWM Headers, not MXP or DIO\0";
pub const HAL_INVALID_DMA_ADDITION: i32 = -1102;
pub const HAL_INVALID_DMA_ADDITION_MESSAGE: &[u8; 46] =
    b"HAL_AddDMA() only works before HAL_StartDMA()\0";
pub const HAL_INVALID_DMA_STATE: i32 = -1103;
pub const HAL_INVALID_DMA_STATE_MESSAGE: &[u8; 48] =
    b"HAL_SetPause() only works before HAL_StartDMA()\0";
pub const HAL_SERIAL_PORT_NOT_FOUND: i32 = -1123;
pub const HAL_SERIAL_PORT_NOT_FOUND_MESSAGE: &[u8; 52] =
    b"HAL: The specified serial port device was not found\0";
pub const HAL_SERIAL_PORT_OPEN_ERROR: i32 = -1124;
pub const HAL_SERIAL_PORT_OPEN_ERROR_MESSAGE: &[u8; 41] =
    b"HAL: The serial port could not be opened\0";
pub const HAL_SERIAL_PORT_ERROR: i32 = -1125;
pub const HAL_SERIAL_PORT_ERROR_MESSAGE: &[u8; 43] =
    b"HAL: There was an error on the serial port\0";
pub const HAL_THREAD_PRIORITY_ERROR: i32 = -1152;
pub const HAL_THREAD_PRIORITY_ERROR_MESSAGE: &[u8; 60] =
    b"HAL: Getting or setting the priority of a thread has failed\0";
pub const HAL_THREAD_PRIORITY_RANGE_ERROR: i32 = -1153;
pub const HAL_THREAD_PRIORITY_RANGE_ERROR_MESSAGE: &[u8; 49] =
    b"HAL: The priority requested to be set is invalid\0";
pub const HAL_CAN_TIMEOUT: i32 = -1154;
pub const HAL_CAN_TIMEOUT_MESSAGE: &[u8; 31] = b"HAL: CAN Receive has Timed Out\0";
pub const HAL_SIM_NOT_SUPPORTED: i32 = -1155;
pub const HAL_SIM_NOT_SUPPORTED_MESSAGE: &[u8; 33] = b"HAL: Method not supported in sim\0";
pub const HAL_USE_LAST_ERROR: i32 = -1156;
pub const HAL_USE_LAST_ERROR_MESSAGE: &[u8; 52] =
    b"HAL: Use HAL_GetLastError(status) to get last error\0";
pub const HAL_CONSOLE_OUT_ENABLED_ERROR: i32 = -1157;
pub const HAL_CONSOLE_OUT_ENABLED_ERROR_MESSAGE : & [u8 ; 106] = b"HAL: Onboard serial port is requested, but Console Out is enabled. Disable Console Out using imaging tool\0" ;
pub const HAL_CAN_BUFFER_OVERRUN: i32 = -35007;
pub const HAL_CAN_BUFFER_OVERRUN_MESSAGE: &[u8; 57] =
    b"HAL: CAN Output Buffer Full. Ensure a device is attached\0";
pub const VI_ERROR_SYSTEM_ERROR_MESSAGE: &[u8; 25] = b"HAL - VISA: System Error\0";
pub const VI_ERROR_INV_OBJECT_MESSAGE: &[u8; 27] = b"HAL - VISA: Invalid Object\0";
pub const VI_ERROR_RSRC_LOCKED_MESSAGE: &[u8; 28] = b"HAL - VISA: Resource Locked\0";
pub const VI_ERROR_RSRC_NFOUND_MESSAGE: &[u8; 31] = b"HAL - VISA: Resource Not Found\0";
pub const VI_ERROR_INV_RSRC_NAME_MESSAGE: &[u8; 34] = b"HAL - VISA: Invalid Resource Name\0";
pub const VI_ERROR_QUEUE_OVERFLOW_MESSAGE: &[u8; 27] = b"HAL - VISA: Queue Overflow\0";
pub const VI_ERROR_IO_MESSAGE: &[u8; 29] = b"HAL - VISA: General IO Error\0";
pub const VI_ERROR_ASRL_PARITY_MESSAGE: &[u8; 25] = b"HAL - VISA: Parity Error\0";
pub const VI_ERROR_ASRL_FRAMING_MESSAGE: &[u8; 26] = b"HAL - VISA: Framing Error\0";
pub const VI_ERROR_ASRL_OVERRUN_MESSAGE: &[u8; 33] = b"HAL - VISA: Buffer Overrun Error\0";
pub const VI_ERROR_RSRC_BUSY_MESSAGE: &[u8; 26] = b"HAL - VISA: Resource Busy\0";
pub const VI_ERROR_INV_PARAMETER_MESSAGE: &[u8; 30] = b"HAL - VISA: Invalid Parameter\0";
pub const NT_DEFAULT_PORT3: u32 = 1735;
pub const NT_DEFAULT_PORT4: u32 = 5810;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type HAL_Handle = i32;
pub type HAL_PortHandle = HAL_Handle;
pub type HAL_AnalogInputHandle = HAL_Handle;
pub type HAL_AnalogOutputHandle = HAL_Handle;
pub type HAL_AnalogTriggerHandle = HAL_Handle;
pub type HAL_CompressorHandle = HAL_Handle;
pub type HAL_CounterHandle = HAL_Handle;
pub type HAL_DigitalHandle = HAL_Handle;
pub type HAL_DigitalPWMHandle = HAL_Handle;
pub type HAL_EncoderHandle = HAL_Handle;
pub type HAL_FPGAEncoderHandle = HAL_Handle;
pub type HAL_GyroHandle = HAL_Handle;
pub type HAL_InterruptHandle = HAL_Handle;
pub type HAL_NotifierHandle = HAL_Handle;
pub type HAL_RelayHandle = HAL_Handle;
pub type HAL_SolenoidHandle = HAL_Handle;
pub type HAL_SerialPortHandle = HAL_Handle;
pub type HAL_CANHandle = HAL_Handle;
pub type HAL_SimDeviceHandle = HAL_Handle;
pub type HAL_SimValueHandle = HAL_Handle;
pub type HAL_DMAHandle = HAL_Handle;
pub type HAL_DutyCycleHandle = HAL_Handle;
pub type HAL_AddressableLEDHandle = HAL_Handle;
pub type HAL_PDPHandle = HAL_CANHandle;
pub type HAL_PowerDistributionHandle = HAL_Handle;
pub type HAL_CTREPCMHandle = HAL_Handle;
pub type HAL_REVPDHHandle = HAL_Handle;
pub type HAL_REVPHHandle = HAL_Handle;
pub type HAL_Bool = i32;
#[repr(i32)]
#[doc = " The acceptable accelerometer ranges."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_AccelerometerRange {
    HAL_AccelerometerRange_k2G = 0,
    HAL_AccelerometerRange_k4G = 1,
    HAL_AccelerometerRange_k8G = 2,
}
extern "C" {
    #[doc = " Sets the accelerometer to active or standby mode.\n\n It must be in standby mode to change any configuration.\n\n @param active true to set to active, false for standby"]
    pub fn HAL_SetAccelerometerActive(active: HAL_Bool);
}
extern "C" {
    #[doc = " Sets the range of values that can be measured (either 2, 4, or 8 g-forces).\n\n The accelerometer should be in standby mode when this is called.\n\n @param range the accelerometer range"]
    pub fn HAL_SetAccelerometerRange(range: HAL_AccelerometerRange);
}
extern "C" {
    #[doc = " Gets the x-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the X acceleration"]
    pub fn HAL_GetAccelerometerX() -> f64;
}
extern "C" {
    #[doc = " Gets the y-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the Y acceleration"]
    pub fn HAL_GetAccelerometerY() -> f64;
}
extern "C" {
    #[doc = " Gets the z-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the Z acceleration"]
    pub fn HAL_GetAccelerometerZ() -> f64;
}
extern "C" {
    #[doc = " Is the channel attached to an accumulator.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The analog channel is attached to an accumulator."]
    pub fn HAL_IsAccumulatorChannel(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Initialize the accumulator.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_InitAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Resets the accumulator to the initial value.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ResetAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Set the center value of the accumulator.\n\n The center value is subtracted from each A/D value before it is added to the\n accumulator. This is used for the center value of devices like gyros and\n accelerometers to make integration work and to take the device offset into\n account when integrating.\n\n This center value is based on the output of the oversampled and averaged\n source from channel 1. Because of this, any non-zero oversample bits will\n affect the size of the value for this field.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] center The center value of the accumulator.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAccumulatorCenter(
        analogPortHandle: HAL_AnalogInputHandle,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Set the accumulator's deadband.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] deadband The deadband of the accumulator.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAccumulatorDeadband(
        analogPortHandle: HAL_AnalogInputHandle,
        deadband: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Read the accumulated value.\n\n Read the value that has been accumulating on channel 1.\n The accumulator is attached after the oversample and average engine.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The 64-bit value accumulated since the last Reset()."]
    pub fn HAL_GetAccumulatorValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Read the number of accumulated values.\n\n Read the count of the accumulated values since the accumulator was last\n Reset().\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The number of times samples from the channel were accumulated."]
    pub fn HAL_GetAccumulatorCount(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Read the accumulated value and the number of accumulated values atomically.\n\n This function reads the value and count from the FPGA atomically.\n This can be used for averaging.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] value Pointer to the 64-bit accumulated output.\n @param[in] count Pointer to the number of accumulation cycles.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_GetAccumulatorOutput(
        analogPortHandle: HAL_AnalogInputHandle,
        value: *mut i64,
        count: *mut i64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Initializes an analog gyro.\n\n @param[in] handle handle to the analog input port\n @param[in] allocationLocation the location where the allocation is occurring\n                                (can be null)\n @param[out] status the error code, or 0 for success\n @return the initialized gyro handle"]
    pub fn HAL_InitializeAnalogGyro(
        handle: HAL_AnalogInputHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_GyroHandle;
}
extern "C" {
    #[doc = " Sets up an analog gyro with the proper offsets and settings for the KOP\n analog gyro.\n\n @param[in] handle the gyro handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetupAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Frees an analog gyro.\n\n @param[in,out] handle the gyro handle"]
    pub fn HAL_FreeAnalogGyro(handle: HAL_GyroHandle);
}
extern "C" {
    #[doc = " Sets the analog gyro parameters to the specified values.\n\n This is meant to be used if you want to reuse the values from a previous\n calibration.\n\n @param[in] handle                  the gyro handle\n @param[in] voltsPerDegreePerSecond the gyro volts scaling\n @param[in] offset                  the gyro offset\n @param[in] center                  the gyro center\n @param[out] status                  the error code, or 0 for success"]
    pub fn HAL_SetAnalogGyroParameters(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        offset: f64,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the analog gyro volts per degrees per second scaling.\n\n @param[in] handle                  the gyro handle\n @param[in] voltsPerDegreePerSecond the gyro volts scaling\n @param[out] status                  the error code, or 0 for success"]
    pub fn HAL_SetAnalogGyroVoltsPerDegreePerSecond(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Resets the analog gyro value to 0.\n\n @param[in] handle the gyro handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ResetAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Calibrates the analog gyro.\n\n This happens by calculating the average value of the gyro over 5 seconds, and\n setting that as the center. Note that this call blocks for 5 seconds to\n perform this.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CalibrateAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the deadband of the analog gyro.\n\n @param[in] handle the gyro handle\n @param[in] volts  the voltage deadband\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAnalogGyroDeadband(handle: HAL_GyroHandle, volts: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the gyro angle in degrees.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro angle in degrees"]
    pub fn HAL_GetAnalogGyroAngle(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the gyro rate in degrees/second.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro rate in degrees/second"]
    pub fn HAL_GetAnalogGyroRate(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the calibrated gyro offset.\n\n Can be used to not repeat a calibration but reconstruct the gyro object.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gryo offset"]
    pub fn HAL_GetAnalogGyroOffset(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the calibrated gyro center.\n\n Can be used to not repeat a calibration but reconstruct the gyro object.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro center"]
    pub fn HAL_GetAnalogGyroCenter(handle: HAL_GyroHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Initializes the analog input port using the given port object.\n\n @param[in] portHandle Handle to the port to initialize.\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status the error code, or 0 for success\n @return the created analog input handle"]
    pub fn HAL_InitializeAnalogInputPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_AnalogInputHandle;
}
extern "C" {
    #[doc = " Frees an analog input port.\n\n @param[in,out] analogPortHandle Handle to the analog port."]
    pub fn HAL_FreeAnalogInputPort(analogPortHandle: HAL_AnalogInputHandle);
}
extern "C" {
    #[doc = " Checks that the analog module number is valid.\n\n @param[in] module The analog module number.\n @return Analog module is valid and present"]
    pub fn HAL_CheckAnalogModule(module: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks that the analog output channel number is valid.\n Verifies that the analog channel number is one of the legal channel numbers.\n Channel numbers are 0-based.\n\n @param[in] channel The analog output channel number.\n @return Analog channel is valid"]
    pub fn HAL_CheckAnalogInputChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Indicates the analog input is used by a simulated device.\n\n @param handle the analog input handle\n @param device simulated device handle"]
    pub fn HAL_SetAnalogInputSimDevice(handle: HAL_AnalogInputHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Sets the sample rate.\n\n This is a global setting for the Athena and effects all channels.\n\n @param[in] samplesPerSecond The number of samples per channel per second.\n @param[out] status          the error code, or 0 for success"]
    pub fn HAL_SetAnalogSampleRate(samplesPerSecond: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current sample rate.\n\n This assumes one entry in the scan list.\n This is a global setting for the Athena and effects all channels.\n\n @param[out] status the error code, or 0 for success\n @return Sample rate."]
    pub fn HAL_GetAnalogSampleRate(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the number of averaging bits.\n\n This sets the number of averaging bits. The actual number of averaged samples\n is 2**bits. Use averaging to improve the stability of your measurement at the\n expense of sampling rate. The averaging is done automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to configure.\n @param[in] bits Number of bits to average.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of averaging bits.\n\n This gets the number of averaging bits from the FPGA. The actual number of\n averaged samples is 2**bits. The averaging is done automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return Bits to average."]
    pub fn HAL_GetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the number of oversample bits.\n\n This sets the number of oversample bits. The actual number of oversampled\n values is 2**bits. Use oversampling to improve the resolution of your\n measurements at the expense of sampling rate. The oversampling is done\n automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[in] bits Number of bits to oversample.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of oversample bits.\n\n This gets the number of oversample bits from the FPGA. The actual number of\n oversampled values is 2**bits. The oversampling is done automatically in the\n FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status          the error code, or 0 for success\n @return Bits to oversample."]
    pub fn HAL_GetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a sample straight from the channel on this module.\n\n The sample is a 12-bit value representing the 0V to 5V range of the A/D\n converter in the module. The units are in A/D converter codes.  Use\n GetVoltage() to get the analog value in calibrated units.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A sample straight from the channel on this module."]
    pub fn HAL_GetAnalogValue(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets a sample from the output of the oversample and average engine for the\n channel.\n\n The sample is 12-bit + the value configured in SetOversampleBits().\n The value configured in SetAverageBits() will cause this value to be averaged\n 2**bits number of samples. This is not a sliding window.  The sample will not\n change until 2**(OversampleBits + AverageBits) samples have been acquired\n from the module on this channel. Use GetAverageVoltage() to get the analog\n value in calibrated units.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A sample from the oversample and average engine for the channel."]
    pub fn HAL_GetAnalogAverageValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Converts a voltage to a raw value for a specified channel.\n\n This process depends on the calibration of each channel, so the channel must\n be specified.\n\n @todo This assumes raw values.  Oversampling not supported as is.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[in] voltage The voltage to convert.\n @param[out] status the error code, or 0 for success\n @return The raw value for the channel."]
    pub fn HAL_GetAnalogVoltsToValue(
        analogPortHandle: HAL_AnalogInputHandle,
        voltage: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a scaled sample straight from the channel on this module.\n\n The value is scaled to units of Volts using the calibrated scaling data from\n GetLSBWeight() and GetOffset().\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A scaled sample straight from the channel on this module."]
    pub fn HAL_GetAnalogVoltage(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets a scaled sample from the output of the oversample and average engine for\n the channel.\n\n The value is scaled to units of Volts using the calibrated scaling data from\n GetLSBWeight() and GetOffset(). Using oversampling will cause this value to\n be higher resolution, but it will update more slowly. Using averaging will\n cause this value to be more stable, but it will update more slowly.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A scaled sample from the output of the oversample and average engine\n for the channel."]
    pub fn HAL_GetAnalogAverageVoltage(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the factory scaling least significant bit weight constant.\n The least significant bit weight constant for the channel that was calibrated\n in manufacturing and stored in an eeprom in the module.\n\n Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return Least significant bit weight."]
    pub fn HAL_GetAnalogLSBWeight(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32)
        -> i32;
}
extern "C" {
    #[doc = " Gets the factory scaling offset constant.\n The offset constant for the channel that was calibrated in manufacturing and\n stored in an eeprom in the module.\n\n Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status Error status variable. 0 on success.\n @return Offset constant."]
    pub fn HAL_GetAnalogOffset(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = "  Get the analog voltage from a raw value.\n\n @param[in] analogPortHandle  Handle to the analog port the values were read\n                              from.\n @param[in] rawValue          The raw analog value\n @param[out] status           Error status variable. 0 on success.\n @return The voltage relating to the value"]
    pub fn HAL_GetAnalogValueToVolts(
        analogPortHandle: HAL_AnalogInputHandle,
        rawValue: i32,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Initializes the analog output port using the given port object.\n\n @param[in] portHandle handle to the port\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status Error status variable. 0 on success.\n @return the created analog output handle"]
    pub fn HAL_InitializeAnalogOutputPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_AnalogOutputHandle;
}
extern "C" {
    #[doc = " Frees an analog output port.\n\n @param analogOutputHandle the analog output handle"]
    pub fn HAL_FreeAnalogOutputPort(analogOutputHandle: HAL_AnalogOutputHandle);
}
extern "C" {
    #[doc = " Sets an analog output value.\n\n @param[in] analogOutputHandle the analog output handle\n @param[in] voltage            the voltage (0-5v) to output\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_SetAnalogOutput(
        analogOutputHandle: HAL_AnalogOutputHandle,
        voltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current analog output value.\n\n @param[in] analogOutputHandle the analog output handle\n @param[out] status            Error status variable. 0 on success.\n @return the current output voltage (0-5v)"]
    pub fn HAL_GetAnalogOutput(analogOutputHandle: HAL_AnalogOutputHandle, status: *mut i32)
        -> f64;
}
extern "C" {
    #[doc = " Checks that the analog output channel number is valid.\n\n Verifies that the analog channel number is one of the legal channel numbers.\n Channel numbers are 0-based.\n\n @return Analog channel is valid"]
    pub fn HAL_CheckAnalogOutputChannel(channel: i32) -> HAL_Bool;
}
#[repr(i32)]
#[doc = " The type of analog trigger to trigger on."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_AnalogTriggerType {
    HAL_Trigger_kInWindow = 0,
    HAL_Trigger_kState = 1,
    HAL_Trigger_kRisingPulse = 2,
    HAL_Trigger_kFallingPulse = 3,
}
extern "C" {
    #[doc = " Initializes an analog trigger.\n\n @param[in] portHandle the analog input to use for triggering\n @param[out] status     Error status variable. 0 on success.\n @return the created analog trigger handle"]
    pub fn HAL_InitializeAnalogTrigger(
        portHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    #[doc = " Initializes an analog trigger with a Duty Cycle input\n\n @param[in] dutyCycleHandle the analog input to use for duty cycle\n @param[out] status          Error status variable. 0 on success.\n @return tbe created analog trigger handle"]
    pub fn HAL_InitializeAnalogTriggerDutyCycle(
        dutyCycleHandle: HAL_DutyCycleHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    #[doc = " Frees an analog trigger.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CleanAnalogTrigger(analogTriggerHandle: HAL_AnalogTriggerHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the raw ADC upper and lower limits of the analog trigger.\n\n HAL_SetAnalogTriggerLimitsVoltage or HAL_SetAnalogTriggerLimitsDutyCycle\n is likely better in most cases.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower ADC value\n @param[in] upper               the upper ADC value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsRaw(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: i32,
        upper: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the upper and lower limits of the analog trigger.\n\n The limits are given as floating point voltage values.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower voltage value\n @param[in] upper               the upper voltage value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsVoltage(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the upper and lower limits of the analog trigger.\n\n The limits are given as floating point duty cycle values.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower duty cycle value\n @param[in] upper               the upper duty cycle value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsDutyCycle(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the analog trigger to use the averaged vs. raw values.\n\n If the value is true, then the averaged value is selected for the analog\n trigger, otherwise the immediate value is used.\n\n This is not allowed to be used if filtered mode is set.\n This is not allowed to be used with Duty Cycle based inputs.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] useAveragedValue    true to use averaged values, false for raw\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerAveraged(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useAveragedValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the analog trigger to use a filtered value.\n\n The analog trigger will operate with a 3 point average rejection filter. This\n is designed to help with 360 degree pot applications for the period where the\n pot crosses through zero.\n\n This is not allowed to be used if averaged mode is set.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] useFilteredValue    true to use filtered values, false for average\n                                or raw\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerFiltered(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useFilteredValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Returns the InWindow output of the analog trigger.\n\n True if the analog input is between the upper and lower limits.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status Error status variable. 0 on success.\n @return the InWindow output of the analog trigger"]
    pub fn HAL_GetAnalogTriggerInWindow(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the TriggerState output of the analog trigger.\n\n True if above upper limit.\n False if below lower limit.\n If in Hysteresis, maintain previous state.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status              Error status variable. 0 on success.\n @return the TriggerState output of the analog trigger"]
    pub fn HAL_GetAnalogTriggerTriggerState(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the state of the analog trigger output.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] type                the type of trigger to trigger on\n @param[out] status              Error status variable. 0 on success.\n @return the state of the analog trigger output"]
    pub fn HAL_GetAnalogTriggerOutput(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        type_: HAL_AnalogTriggerType,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Get the FPGA index for the AnlogTrigger.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status              Error status variable. 0 on success.\n @return the FPGA index"]
    pub fn HAL_GetAnalogTriggerFPGAIndex(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> i32;
}
#[doc = " Storage for CAN Stream Messages."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_CANStreamMessage {
    pub messageID: u32,
    pub timeStamp: u32,
    pub data: [u8; 8usize],
    pub dataSize: u8,
}
#[test]
fn bindgen_test_layout_HAL_CANStreamMessage() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_CANStreamMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_CANStreamMessage>(),
        20usize,
        concat!("Size of: ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_CANStreamMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(messageID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(dataSize)
        )
    );
}
extern "C" {
    #[doc = " Sends a CAN message.\n\n @param[in] messageID the CAN ID to send\n @param[in] data      the data to send (0-8 bytes)\n @param[in] dataSize  the size of the data to send (0-8 bytes)\n @param[in] periodMs  the period to repeat the packet at. Use\n                       HAL_CAN_SEND_PERIOD_NO_REPEAT to not repeat.\n @param[out] status    Error status variable. 0 on success."]
    pub fn HAL_CAN_SendMessage(
        messageID: u32,
        data: *const u8,
        dataSize: u8,
        periodMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Receives a CAN message.\n\n @param[out] messageID     store for the received message ID\n @param[in] messageIDMask the message ID mask to look for\n @param[out] data          data output (8 bytes)\n @param[out] dataSize      data length (0-8 bytes)\n @param[out] timeStamp     the packet received timestamp (based off of\n                           CLOCK_MONOTONIC)\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_CAN_ReceiveMessage(
        messageID: *mut u32,
        messageIDMask: u32,
        data: *mut u8,
        dataSize: *mut u8,
        timeStamp: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Opens a CAN stream.\n\n @param[out] sessionHandle output for the session handle\n @param[in] messageID     the message ID to read\n @param[in] messageIDMask the mssage ID mask\n @param[in] maxMessages   the maximum number of messages to stream\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_CAN_OpenStreamSession(
        sessionHandle: *mut u32,
        messageID: u32,
        messageIDMask: u32,
        maxMessages: u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Closes a CAN stream.\n\n @param sessionHandle the session to close"]
    pub fn HAL_CAN_CloseStreamSession(sessionHandle: u32);
}
extern "C" {
    #[doc = " Reads a CAN stream message.\n\n @param[in] sessionHandle  the session handle\n @param[in] messages       array of messages\n @param[in] messagesToRead the max number of messages to read\n @param[out] messagesRead   the number of messages actually read\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_CAN_ReadStreamSession(
        sessionHandle: u32,
        messages: *mut HAL_CANStreamMessage,
        messagesToRead: u32,
        messagesRead: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets CAN status information.\n\n @param[out] percentBusUtilization the bus utilization\n @param[out] busOffCount           the number of bus off errors\n @param[out] txFullCount           the number of tx full errors\n @param[out] receiveErrorCount     the number of receive errors\n @param[out] transmitErrorCount    the number of transmit errors\n @param[out] status                Error status variable. 0 on success."]
    pub fn HAL_CAN_GetCANStatus(
        percentBusUtilization: *mut f32,
        busOffCount: *mut u32,
        txFullCount: *mut u32,
        receiveErrorCount: *mut u32,
        transmitErrorCount: *mut u32,
        status: *mut i32,
    );
}
#[repr(i32)]
#[doc = " The CAN device type.\n\n Teams should use HAL_CAN_Dev_kMiscellaneous"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_CANDeviceType {
    #[doc = " Broadcast."]
    HAL_CAN_Dev_kBroadcast = 0,
    #[doc = " Robot controller."]
    HAL_CAN_Dev_kRobotController = 1,
    #[doc = " Motor controller."]
    HAL_CAN_Dev_kMotorController = 2,
    #[doc = " Relay controller."]
    HAL_CAN_Dev_kRelayController = 3,
    #[doc = " Gyro sensor."]
    HAL_CAN_Dev_kGyroSensor = 4,
    #[doc = " Accelerometer."]
    HAL_CAN_Dev_kAccelerometer = 5,
    #[doc = " Ultrasonic sensor."]
    HAL_CAN_Dev_kUltrasonicSensor = 6,
    #[doc = " Gear tooth sensor."]
    HAL_CAN_Dev_kGearToothSensor = 7,
    #[doc = " Power distribution."]
    HAL_CAN_Dev_kPowerDistribution = 8,
    #[doc = " Pneumatics."]
    HAL_CAN_Dev_kPneumatics = 9,
    #[doc = " Miscellaneous."]
    HAL_CAN_Dev_kMiscellaneous = 10,
    #[doc = " IO breakout."]
    HAL_CAN_Dev_kIOBreakout = 11,
    #[doc = " Firmware update."]
    HAL_CAN_Dev_kFirmwareUpdate = 31,
}
#[repr(i32)]
#[doc = " The CAN manufacturer ID.\n\n Teams should use HAL_CAN_Man_kTeamUse."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_CANManufacturer {
    #[doc = " Broadcast."]
    HAL_CAN_Man_kBroadcast = 0,
    #[doc = " National Instruments."]
    HAL_CAN_Man_kNI = 1,
    #[doc = " Luminary Micro."]
    HAL_CAN_Man_kLM = 2,
    #[doc = " DEKA Research and Development Corp."]
    HAL_CAN_Man_kDEKA = 3,
    #[doc = " Cross the Road Electronics."]
    HAL_CAN_Man_kCTRE = 4,
    #[doc = " REV robotics."]
    HAL_CAN_Man_kREV = 5,
    #[doc = " Grapple."]
    HAL_CAN_Man_kGrapple = 6,
    #[doc = " MindSensors."]
    HAL_CAN_Man_kMS = 7,
    #[doc = " Team use."]
    HAL_CAN_Man_kTeamUse = 8,
    #[doc = " Kauai Labs."]
    HAL_CAN_Man_kKauaiLabs = 9,
    #[doc = " Copperforge."]
    HAL_CAN_Man_kCopperforge = 10,
    #[doc = " Playing With Fusion."]
    HAL_CAN_Man_kPWF = 11,
    #[doc = " Studica."]
    HAL_CAN_Man_kStudica = 12,
    #[doc = " TheThriftyBot."]
    HAL_CAN_Man_kTheThriftyBot = 13,
    #[doc = " Redux Robotics."]
    HAL_CAN_Man_kReduxRobotics = 14,
    #[doc = " AndyMark."]
    HAL_CAN_Man_kAndyMark = 15,
    #[doc = " Vivid-Hosting."]
    HAL_CAN_Man_kVividHosting = 16,
}
extern "C" {
    #[doc = " Reads the current value of the millisecond-resolution timer that the CAN API\n functions use as a time base.\n\n @return Current value of timer used as a base time by the CAN API in\n milliseconds."]
    pub fn HAL_GetCANPacketBaseTime() -> u32;
}
extern "C" {
    #[doc = " Initializes a CAN device.\n\n These follow the FIRST standard CAN layout.\n https://docs.wpilib.org/en/stable/docs/software/can-devices/can-addressing.html\n\n @param[in] manufacturer the can manufacturer\n @param[in] deviceId     the device ID (0-63)\n @param[in] deviceType   the device type\n @param[out] status      Error status variable. 0 on success.\n @return the created CAN handle"]
    pub fn HAL_InitializeCAN(
        manufacturer: HAL_CANManufacturer,
        deviceId: i32,
        deviceType: HAL_CANDeviceType,
        status: *mut i32,
    ) -> HAL_CANHandle;
}
extern "C" {
    #[doc = " Frees a CAN device\n\n @param[in,out] handle the CAN handle"]
    pub fn HAL_CleanCAN(handle: HAL_CANHandle);
}
extern "C" {
    #[doc = " Writes a packet to the CAN device with a specific ID.\n\n This ID is 10 bits.\n\n @param[in] handle  the CAN handle\n @param[in] data    the data to write (0-8 bytes)\n @param[in] length  the length of data (0-8)\n @param[in] apiId   the ID to write (0-1023 bits)\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_WriteCANPacket(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes a repeating packet to the CAN device with a specific ID.\n\n This ID is 10 bits.\n\n The RoboRIO will automatically repeat the packet at the specified interval\n\n @param[in] handle   the CAN handle\n @param[in] data     the data to write (0-8 bytes)\n @param[in] length   the length of data (0-8)\n @param[in] apiId    the ID to write (0-1023)\n @param[in] repeatMs the period to repeat in ms\n @param[out] status  Error status variable. 0 on success."]
    pub fn HAL_WriteCANPacketRepeating(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        repeatMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes an RTR frame of the specified length to the CAN device with the\n specific ID.\n\n By spec, the length must be equal to the length sent by the other device,\n otherwise behavior is unspecified.\n\n @param[in] handle   the CAN handle\n @param[in] length   the length of data to request (0-8)\n @param[in] apiId    the ID to write (0-1023)\n @param[out] status  Error status variable. 0 on success."]
    pub fn HAL_WriteCANRTRFrame(handle: HAL_CANHandle, length: i32, apiId: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Stops a repeating packet with a specific ID.\n\n This ID is 10 bits.\n\n @param[in] handle  the CAN handle\n @param[in] apiId   the ID to stop repeating (0-1023)\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_StopCANPacketRepeating(handle: HAL_CANHandle, apiId: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Reads a new CAN packet.\n\n This will only return properly once per packet received. Multiple calls\n without receiving another packet will return an error code.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp in ms (based off\n                               of CLOCK_MONOTONIC)\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketNew(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads a CAN packet. The will continuously return the last packet received,\n without accounting for packet age.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp in ms (based off\n                               of CLOCK_MONOTONIC)\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketLatest(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads a CAN packet. The will return the last packet received until the\n packet is older then the requested timeout. Then it will return an error\n code.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp in ms (based off\n                               of CLOCK_MONOTONIC)\n @param[out] timeoutMs         the timeout time for the packet\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketTimeout(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        timeoutMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Initializes a PCM.\n\n @param[in] module             the CAN ID to initialize\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status            Error status variable. 0 on success.\n @return the created PH handle"]
    pub fn HAL_InitializeCTREPCM(
        module: i32,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_CTREPCMHandle;
}
extern "C" {
    #[doc = " Frees a PCM handle.\n\n @param[in] handle the PCMhandle"]
    pub fn HAL_FreeCTREPCM(handle: HAL_CTREPCMHandle);
}
extern "C" {
    #[doc = " Checks if a solenoid channel number is valid.\n\n @param[in] channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckCTREPCMSolenoidChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Get whether compressor is turned on.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return true if the compressor is turned on"]
    pub fn HAL_GetCTREPCMCompressor(handle: HAL_CTREPCMHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Enables the compressor closed loop control using the digital pressure switch.\n The compressor will turn on when the pressure switch indicates that the\n system is not full, and will turn off when the pressure switch indicates that\n the system is full.\n\n @param[in] handle  the PCM handle\n @param[in] enabled true to enable closed loop control\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetCTREPCMClosedLoopControl(
        handle: HAL_CTREPCMHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Get whether the PCM closed loop control is enabled.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if closed loop control is enabled, otherwise false."]
    pub fn HAL_GetCTREPCMClosedLoopControl(handle: HAL_CTREPCMHandle, status: *mut i32)
        -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the state of the pressure switch.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if pressure switch indicates that the system is full,\n otherwise false."]
    pub fn HAL_GetCTREPCMPressureSwitch(handle: HAL_CTREPCMHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the current drawn by the compressor.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return The current drawn by the compressor in amps."]
    pub fn HAL_GetCTREPCMCompressorCurrent(handle: HAL_CTREPCMHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Return whether the compressor current is currently too high.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor current is too high, otherwise false.\n @see HAL_GetCTREPCMCompressorShortedStickyFault"]
    pub fn HAL_GetCTREPCMCompressorCurrentTooHighFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor current has been too high since sticky\n faults were last cleared. This fault is persistent and can be cleared by\n HAL_ClearAllCTREPCMStickyFaults()\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor current has been too high since sticky\n faults were last cleared.\n @see HAL_GetCTREPCMCompressorCurrentTooHighFault()"]
    pub fn HAL_GetCTREPCMCompressorCurrentTooHighStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor has been shorted since sticky faults were\n last cleared. This fault is persistent and can be cleared by\n HAL_ClearAllCTREPCMStickyFaults()\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor has been shorted since sticky faults were\n last cleared, otherwise false.\n @see HAL_GetCTREPCMCompressorShortedFault()"]
    pub fn HAL_GetCTREPCMCompressorShortedStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor is currently shorted.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor is currently shorted, otherwise false.\n @see HAL_GetCTREPCMCompressorShortedStickyFault"]
    pub fn HAL_GetCTREPCMCompressorShortedFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor has been disconnected since sticky faults\n were last cleared. This fault is persistent and can be cleared by\n HAL_ClearAllCTREPCMStickyFaults()\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if the compressor has been disconnected since sticky faults\n were last cleared, otherwise false.\n @see HAL_GetCTREPCMCompressorShortedFault()"]
    pub fn HAL_GetCTREPCMCompressorNotConnectedStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the compressor is currently disconnected.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if compressor is currently disconnected, otherwise false.\n @see HAL_GetCTREPCMCompressorNotConnectedStickyFault()"]
    pub fn HAL_GetCTREPCMCompressorNotConnectedFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets a bitmask of solenoid values.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return solenoid values"]
    pub fn HAL_GetCTREPCMSolenoids(handle: HAL_CTREPCMHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets solenoids on a pneumatics module.\n\n @param[in] handle  the PCM handle\n @param[in] mask bitmask to set\n @param[in] values solenoid values\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetCTREPCMSolenoids(
        handle: HAL_CTREPCMHandle,
        mask: i32,
        values: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Get a bitmask of disabled solenoids.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return bitmask of disabled solenoids"]
    pub fn HAL_GetCTREPCMSolenoidDisabledList(handle: HAL_CTREPCMHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Returns whether the solenoid has reported a voltage fault since sticky faults\n were last cleared. This fault is persistent and can be cleared by\n HAL_ClearAllCTREPCMStickyFaults()\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if solenoid is reporting a fault, otherwise false.\n @see HAL_GetCTREPCMSolenoidVoltageFault()"]
    pub fn HAL_GetCTREPCMSolenoidVoltageStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns whether the solenoid is currently reporting a voltage fault.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success.\n @return True if solenoid is reporting a fault, otherwise false.\n @see HAL_GetCTREPCMSolenoidVoltageStickyFault()"]
    pub fn HAL_GetCTREPCMSolenoidVoltageFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Clears all sticky faults on this device.\n\n @param[in] handle  the PCM handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ClearAllCTREPCMStickyFaults(handle: HAL_CTREPCMHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Fire a single solenoid shot.\n\n @param[in] handle  the PCM handle\n @param[in] index solenoid index\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_FireCTREPCMOneShot(handle: HAL_CTREPCMHandle, index: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Set the duration for a single solenoid shot.\n\n @param[in] handle  the PCM handle\n @param[in] index solenoid index\n @param[in] durMs shot duration in ms\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetCTREPCMOneShotDuration(
        handle: HAL_CTREPCMHandle,
        index: i32,
        durMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of FPGA system clock ticks per microsecond.\n\n @return the number of clock ticks per microsecond"]
    pub fn HAL_GetSystemClockTicksPerMicrosecond() -> i32;
}
#[repr(i32)]
#[doc = " The counter mode."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_Counter_Mode {
    HAL_Counter_kTwoPulse = 0,
    HAL_Counter_kSemiperiod = 1,
    HAL_Counter_kPulseLength = 2,
    HAL_Counter_kExternalDirection = 3,
}
extern "C" {
    #[doc = " Initializes a counter.\n\n @param[in] mode    the counter mode\n @param[in] index   the compressor index (output)\n @param[out] status Error status variable. 0 on success.\n @return the created handle"]
    pub fn HAL_InitializeCounter(
        mode: HAL_Counter_Mode,
        index: *mut i32,
        status: *mut i32,
    ) -> HAL_CounterHandle;
}
extern "C" {
    #[doc = " Frees a counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_FreeCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the average sample size of a counter.\n\n @param[in] counterHandle  the counter handle\n @param[in] size           the size of samples to average\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterAverageSize(counterHandle: HAL_CounterHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the source object that causes the counter to count up.\n\n @param[in] counterHandle       the counter handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the up source to either detect rising edges or falling edges.\n\n Note that both are allowed to be set true at the same time without issues.\n\n @param[in] counterHandle  the counter handle\n @param[in] risingEdge     true to trigger on rising\n @param[in] fallingEdge    true to trigger on falling\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables the up counting source to the counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ClearCounterUpSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the source object that causes the counter to count down.\n\n @param[in] counterHandle       the counter handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetCounterDownSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the down source to either detect rising edges or falling edges.\n Note that both are allowed to be set true at the same time without issues.\n\n @param[in] counterHandle  the counter handle\n @param[in] risingEdge     true to trigger on rising\n @param[in] fallingEdge    true to trigger on falling\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterDownSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables the down counting source to the counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ClearCounterDownSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets standard up / down counting mode on this counter.\n\n Up and down counts are sourced independently from two inputs.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpDownMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets directional counting mode on this counter.\n\n The direction is determined by the B input, with counting happening with the\n A input.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterExternalDirectionMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets Semi-period mode on this counter.\n\n The counter counts up based on the time the input is triggered. High or Low\n depends on the highSemiPeriod parameter.\n\n @param[in] counterHandle  the counter handle\n @param[in] highSemiPeriod true for counting when the input is high, false for\n                           low\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterSemiPeriodMode(
        counterHandle: HAL_CounterHandle,
        highSemiPeriod: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the counter to count in up or down based on the length of the\n input pulse.\n\n This mode is most useful for direction sensitive gear tooth sensors.\n\n @param[in] counterHandle the counter handle\n @param[in] threshold     The pulse length beyond which the counter counts the\n                          opposite direction (seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterPulseLengthMode(
        counterHandle: HAL_CounterHandle,
        threshold: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period. Perform averaging to account\n for mechanical imperfections or as oversampling to increase resolution.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return SamplesToAverage The number of samples being averaged (from 1 to 127)"]
    pub fn HAL_GetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period. Perform averaging to account\n for mechanical imperfections or as oversampling to increase resolution.\n\n @param[in] counterHandle    the counter handle\n @param[in] samplesToAverage The number of samples to average from 1 to 127\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Resets the Counter to zero.\n\n Sets the counter value to zero. This does not effect the running state of the\n counter, just sets the current value to zero.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ResetCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Reads the current counter value.\n\n Reads the value at this instant. It may still be running, so it reflects the\n current value. Next time it is read, it might have a different value.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return the current counter value"]
    pub fn HAL_GetCounter(counterHandle: HAL_CounterHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the Period of the most recent count.\n\n Returns the time interval of the most recent count. This can be used for\n velocity calculations to determine shaft speed.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return the period of the last two pulses in units of seconds"]
    pub fn HAL_GetCounterPeriod(counterHandle: HAL_CounterHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the maximum period where the device is still considered \"moving\".\n\n Sets the maximum period where the device is considered moving. This value is\n used to determine the \"stopped\" state of the counter using the\n HAL_GetCounterStopped method.\n\n @param[in] counterHandle the counter handle\n @param[in] maxPeriod     the maximum period where the counted device is\n                          considered moving in seconds\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterMaxPeriod(
        counterHandle: HAL_CounterHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Selects whether you want to continue updating the event timer output when\n there are no samples captured.\n\n The output of the event timer has a buffer of periods that are averaged and\n posted to a register on the FPGA.  When the timer detects that the event\n source has stopped (based on the MaxPeriod) the buffer of samples to be\n averaged is emptied.\n\n If you enable the update when empty, you will be\n notified of the stopped source and the event time will report 0 samples.\n\n If you disable update when empty, the most recent average will remain on the\n output until a new sample is acquired.\n\n You will never see 0 samples output (except when there have been no events\n since an FPGA reset) and you will likely not see the stopped bit become true\n (since it is updated at the end of an average and there are no samples to\n average).\n\n @param[in] counterHandle the counter handle\n @param[in] enabled       true to enable counter updating with no samples\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpdateWhenEmpty(
        counterHandle: HAL_CounterHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Determines if the clock is stopped.\n\n Determine if the clocked input is stopped based on the MaxPeriod value set\n using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n device (and counter) are assumed to be stopped and it returns true.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return true if the most recent counter period exceeds the MaxPeriod value\n         set by SetMaxPeriod"]
    pub fn HAL_GetCounterStopped(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the last direction the counter value changed.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return the last direction the counter value changed"]
    pub fn HAL_GetCounterDirection(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the Counter to return reversed sensing on the direction.\n\n This allows counters to change the direction they are counting in the case of\n 1X and 2X quadrature encoding only. Any other counter mode isn't supported.\n\n @param[in] counterHandle    the counter handle\n @param[in] reverseDirection true if the value counted should be negated.\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetCounterReverseDirection(
        counterHandle: HAL_CounterHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Creates a new instance of a digital port.\n\n @param[in] portHandle         the port handle to create from\n @param[in] input              true for input, false for output\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status            Error status variable. 0 on success.\n @return the created digital handle"]
    pub fn HAL_InitializeDIOPort(
        portHandle: HAL_PortHandle,
        input: HAL_Bool,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    #[doc = " Checks if a DIO channel is valid.\n\n @param channel the channel number to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckDIOChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Frees a DIO port.\n\n @param dioPortHandle the DIO channel handle"]
    pub fn HAL_FreeDIOPort(dioPortHandle: HAL_DigitalHandle);
}
extern "C" {
    #[doc = " Indicates the DIO channel is used by a simulated device.\n\n @param handle the DIO channel handle\n @param device simulated device handle"]
    pub fn HAL_SetDIOSimDevice(handle: HAL_DigitalHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Allocates a DO PWM Generator.\n\n @param[out] status Error status variable. 0 on success.\n @return the allocated digital PWM handle"]
    pub fn HAL_AllocateDigitalPWM(status: *mut i32) -> HAL_DigitalPWMHandle;
}
extern "C" {
    #[doc = " Frees the resource associated with a DO PWM generator.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_FreeDigitalPWM(pwmGenerator: HAL_DigitalPWMHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Changes the frequency of the DO PWM generator.\n\n The valid range is from 0.6 Hz to 19 kHz.\n\n The frequency resolution is logarithmic.\n\n @param[in] rate the frequency to output all digital output PWM signals\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMRate(rate: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Configures the duty-cycle of the PWM generator.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] dutyCycle    the percent duty cycle to output [0..1]\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMDutyCycle(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the digital PWM to be a PPS signal with specified duty cycle.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] dutyCycle    the percent duty cycle to output [0..1]\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMPPS(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures which DO channel the PWM signal is output on.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] channel      the channel to output on\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMOutputChannel(
        pwmGenerator: HAL_DigitalPWMHandle,
        channel: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes a digital value to a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] value         the state to set the digital channel (if it is\n                          configured as an output)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetDIO(dioPortHandle: HAL_DigitalHandle, value: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the direction of a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] input         true to set input, false for output\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetDIODirection(dioPortHandle: HAL_DigitalHandle, input: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Reads a digital value from a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return the state of the specified channel"]
    pub fn HAL_GetDIO(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Reads the direction of a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return true for input, false for output"]
    pub fn HAL_GetDIODirection(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Generates a single digital pulse.\n\n Write a pulse to the specified digital output channel. There can only be a\n single pulse going at any time.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] pulseLengthSeconds   the active length of the pulse (in seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_Pulse(dioPortHandle: HAL_DigitalHandle, pulseLengthSeconds: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Generates a single digital pulse on multiple channels.\n\n Write a pulse to the channels enabled by the mask. There can only be a\n single pulse going at any time.\n\n @param[in] channelMask the channel mask\n @param[in] pulseLengthSeconds   the active length of the pulse (in seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_PulseMultiple(channelMask: u32, pulseLengthSeconds: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Checks a DIO line to see if it is currently generating a pulse.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status Error status variable. 0 on success.\n @return true if a pulse is in progress, otherwise false"]
    pub fn HAL_IsPulsing(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks if any DIO line is currently generating a pulse.\n\n @param[out] status Error status variable. 0 on success.\n @return true if a pulse on some line is in progress"]
    pub fn HAL_IsAnyPulsing(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Writes the filter index from the FPGA.\n\n Set the filter index used to filter out short pulses.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] filterIndex   the filter index (Must be in the range 0 - 3, where\n                          0 means \"none\" and 1 - 3 means filter # filterIndex\n                          - 1)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetFilterSelect(
        dioPortHandle: HAL_DigitalHandle,
        filterIndex: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads the filter index from the FPGA.\n\n Gets the filter index used to filter out short pulses.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return filterIndex  the filter index (Must be in the range 0 - 3, where 0\n                      means \"none\" and 1 - 3 means filter # filterIndex - 1)"]
    pub fn HAL_GetFilterSelect(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets the filter period for the specified filter index.\n\n Sets the filter period in FPGA cycles.  Even though there are 2 different\n filter index domains (MXP vs HDR), ignore that distinction for now since it\n complicates the interface.  That can be changed later.\n\n @param[in] filterIndex the filter index, 0 - 2\n @param[in] value       the number of cycles that the signal must not\n                        transition to be counted as a transition.\n @param[out] status     Error status variable. 0 on success."]
    pub fn HAL_SetFilterPeriod(filterIndex: i32, value: i64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the filter period for the specified filter index.\n\n Gets the filter period in FPGA cycles.  Even though there are 2 different\n filter index domains (MXP vs HDR), ignore that distinction for now since it\n complicates the interface.  Set status to NiFpga_Status_SoftwareFault if the\n filter values mismatch.\n\n @param[in] filterIndex the filter index, 0 - 2\n @param[out] status     Error status variable. 0 on success.\n @return                The number of FPGA cycles of the filter period."]
    pub fn HAL_GetFilterPeriod(filterIndex: i32, status: *mut i32) -> i64;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " Generic handle for all WPI handle-based interfaces.\n\n Handle data layout:\n - Bits 0-23:  Type-specific\n - Bits 24-30: Type\n - Bit 31:     Error"]
pub type WPI_Handle = ::std::os::raw::c_uint;
#[doc = " An event handle."]
pub type WPI_EventHandle = WPI_Handle;
#[doc = " A semaphore handle."]
pub type WPI_SemaphoreHandle = WPI_Handle;
extern "C" {
    #[doc = " Creates an event.  Events have binary state (signaled or not signaled) and\n may be either automatically reset or manually reset.  Automatic-reset events\n go to non-signaled state when a WaitForObject is woken up by the event;\n manual-reset events require ResetEvent() to be called to set the event to\n non-signaled state; if ResetEvent() is not called, any waiter on that event\n will immediately wake when called.\n\n @param manual_reset true for manual reset, false for automatic reset\n @param initial_state true to make the event initially in signaled state\n @return Event handle"]
    pub fn WPI_CreateEvent(
        manual_reset: ::std::os::raw::c_int,
        initial_state: ::std::os::raw::c_int,
    ) -> WPI_EventHandle;
}
extern "C" {
    #[doc = " Destroys an event.  Destruction wakes up any waiters.\n\n @param handle event handle"]
    pub fn WPI_DestroyEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets an event to signaled state.\n\n @param handle event handle"]
    pub fn WPI_SetEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets an event to non-signaled state.\n\n @param handle event handle"]
    pub fn WPI_ResetEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Creates a semaphore.  Semaphores keep an internal counter.  Releasing the\n semaphore increases the count.  A semaphore with a non-zero count is\n considered signaled.  When a waiter wakes up it atomically decrements the\n count by 1.  This is generally useful in a single-supplier,\n multiple-consumer scenario.\n\n @param initial_count initial value for the semaphore's internal counter\n @param maximum_count maximum value for the samephore's internal counter\n @return Semaphore handle"]
    pub fn WPI_CreateSemaphore(
        initial_count: ::std::os::raw::c_int,
        maximum_count: ::std::os::raw::c_int,
    ) -> WPI_SemaphoreHandle;
}
extern "C" {
    #[doc = " Destroys a semaphore.  Destruction wakes up any waiters.\n\n @param handle semaphore handle"]
    pub fn WPI_DestroySemaphore(handle: WPI_SemaphoreHandle);
}
extern "C" {
    #[doc = " Releases N counts of a semaphore.\n\n @param handle semaphore handle\n @param release_count amount to add to semaphore's internal counter;\n        must be positive\n @param prev_count if non-null, previous count (output parameter)\n @return Non-zero on successful release, zero on failure (e.g. release count\n         would exceed maximum value, or handle invalid)"]
    pub fn WPI_ReleaseSemaphore(
        handle: WPI_SemaphoreHandle,
        release_count: ::std::os::raw::c_int,
        prev_count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for an handle to be signaled.\n\n @param handle handle to wait on\n @return Non-zero if handle was signaled, zero otherwise (e.g. object was\n         destroyed)"]
    pub fn WPI_WaitForObject(handle: WPI_Handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for an handle to be signaled, with timeout.\n\n @param handle handle to wait on\n @param timeout timeout in seconds\n @param timed_out if non-null, set to non-zero if timeout reached without\n        handle being signaled; set to zero otherwise (output)\n @return Non-zero if handle was signaled, zero otherwise (e.g. object was\n         destroyed or timed out)"]
    pub fn WPI_WaitForObjectTimeout(
        handle: WPI_Handle,
        timeout: f64,
        timed_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for one or more handles to be signaled.\n\n Invalid handles are treated as signaled; the returned array will have the\n handle error bit set for any invalid handles.\n\n @param handles array of handles to wait on\n @param handles_count length of the handles array\n @param signaled output array for storage of signaled handles; must be at\n        least the size of the handles input array\n @return number of signaled handles"]
    pub fn WPI_WaitForObjects(
        handles: *const WPI_Handle,
        handles_count: ::std::os::raw::c_int,
        signaled: *mut WPI_Handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for one or more handles to be signaled, with timeout.\n\n Invalid handles are treated as signaled; the returned array will have the\n handle error bit set for any invalid handles.\n\n @param handles array of handles to wait on\n @param handles_count length of the handles array\n @param signaled output array for storage of signaled handles; must be at\n        least the size of the handles input array\n @param timeout timeout in seconds\n @param timed_out if non-null, set to non-zero if timeout reached without any\n        handle being signaled; set to zero otherwise (output)\n @return number of signaled handles"]
    pub fn WPI_WaitForObjectsTimeout(
        handles: *const WPI_Handle,
        handles_count: ::std::os::raw::c_int,
        signaled: *mut WPI_Handle,
        timeout: f64,
        timed_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets up signaling for an arbitrary handle.  With this function, any handle\n can operate like an event handle.\n\n @param handle handle\n @param manual_reset true for manual reset, false for automatic reset\n @param initial_state true to make the handle initially in signaled state"]
    pub fn WPI_CreateSignalObject(
        handle: WPI_Handle,
        manual_reset: ::std::os::raw::c_int,
        initial_state: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets a handle to signaled state.\n\n @param handle handle"]
    pub fn WPI_SetSignalObject(handle: WPI_Handle);
}
extern "C" {
    #[doc = " Sets a handle to non-signaled state.\n\n @param handle handle"]
    pub fn WPI_ResetSignalObject(handle: WPI_Handle);
}
extern "C" {
    #[doc = " Cleans up signaling for a handle.  Destruction wakes up any waiters.\n\n @param handle handle"]
    pub fn WPI_DestroySignalObject(handle: WPI_Handle);
}
#[doc = " A const UTF8 string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPI_String {
    #[doc = " Contents."]
    pub str_: *const ::std::os::raw::c_char,
    #[doc = " Length"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_WPI_String() {
    const UNINIT: ::std::mem::MaybeUninit<WPI_String> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<WPI_String>(),
        16usize,
        concat!("Size of: ", stringify!(WPI_String))
    );
    assert_eq!(
        ::std::mem::align_of::<WPI_String>(),
        8usize,
        concat!("Alignment of ", stringify!(WPI_String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WPI_String),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WPI_String),
            "::",
            stringify!(len)
        )
    );
}
impl Default for WPI_String {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Initializes a WPI_String from a null terminated UTF-8 string.\n If input string is null, initializes output to 0 length.\n The output length does not include the null terminator.\n\n The lifetime of the output string is the lifetime of the input string.\n Do not call WPI_FreeString() with the output of this call.\n\n @param wpiString output string\n @param utf8String input string (null terminated)"]
    pub fn WPI_InitString(wpiString: *mut WPI_String, utf8String: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Initializes a WPI_String from a UTF-8 string and length.\n If input string is null or 0 length, initilizes output to 0 length.\n The input string does not need to be null terminated.\n\n The lifetime of the output string is the lifetime of the input string.\n Do not call WPI_FreeString() with the output of this call.\n\n @param wpiString output string\n @param utf8String input string\n @param length input string length in chars"]
    pub fn WPI_InitStringWithLength(
        wpiString: *mut WPI_String,
        utf8String: *const ::std::os::raw::c_char,
        length: usize,
    );
}
extern "C" {
    #[doc = " Allocates a WPI_String for the specified length.\n The resultant string must be freed with WPI_FreeString().\n\n @param wpiString output string\n @param length string length in chars to allocate\n @return mutable pointer to allocated buffer\n"]
    pub fn WPI_AllocateString(
        wpiString: *mut WPI_String,
        length: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Frees a WPI_String that was allocated with WPI_AllocateString()\n\n @param wpiString string to free"]
    pub fn WPI_FreeString(wpiString: *const WPI_String);
}
extern "C" {
    #[doc = " Allocates an array of WPI_Strings.\n\n @param length array length\n @return string array"]
    pub fn WPI_AllocateStringArray(length: usize) -> *mut WPI_String;
}
extern "C" {
    #[doc = " Frees a WPI_String array returned by WPI_AllocateStringArray().\n\n @param wpiStringArray string array to free\n @param length length of array"]
    pub fn WPI_FreeStringArray(wpiStringArray: *const WPI_String, length: usize);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_ControlWord {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_HAL_ControlWord() {
    assert_eq!(
        ::std::mem::size_of::<HAL_ControlWord>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_ControlWord))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_ControlWord>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_ControlWord))
    );
}
impl HAL_ControlWord {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eStop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eStop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fmsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fmsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn control_reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_control_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u32,
        autonomous: u32,
        test: u32,
        eStop: u32,
        fmsAttached: u32,
        dsAttached: u32,
        control_reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test: u32 = unsafe { ::std::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let eStop: u32 = unsafe { ::std::mem::transmute(eStop) };
            eStop as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fmsAttached: u32 = unsafe { ::std::mem::transmute(fmsAttached) };
            fmsAttached as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsAttached: u32 = unsafe { ::std::mem::transmute(dsAttached) };
            dsAttached as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let control_reserved: u32 = unsafe { ::std::mem::transmute(control_reserved) };
            control_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_AllianceStationID {
    HAL_AllianceStationID_kUnknown = 0,
    HAL_AllianceStationID_kRed1 = 1,
    HAL_AllianceStationID_kRed2 = 2,
    HAL_AllianceStationID_kRed3 = 3,
    HAL_AllianceStationID_kBlue1 = 4,
    HAL_AllianceStationID_kBlue2 = 5,
    HAL_AllianceStationID_kBlue3 = 6,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_MatchType {
    HAL_kMatchType_none = 0,
    HAL_kMatchType_practice = 1,
    HAL_kMatchType_qualification = 2,
    HAL_kMatchType_elimination = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_JoystickAxes {
    pub count: i16,
    pub axes: [f32; 12usize],
    pub raw: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickAxes() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickAxes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickAxes>(),
        64usize,
        concat!("Size of: ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickAxes>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(axes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_JoystickPOVs {
    pub count: i16,
    pub povs: [i16; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickPOVs() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickPOVs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickPOVs>(),
        26usize,
        concat!("Size of: ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickPOVs>(),
        2usize,
        concat!("Alignment of ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povs) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(povs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_JoystickButtons {
    pub buttons: u32,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickButtons() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickButtons> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickButtons>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickButtons>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickDescriptor {
    pub isXbox: u8,
    pub type_: u8,
    pub name: [::std::os::raw::c_char; 256usize],
    pub axisCount: u8,
    pub axisTypes: [u8; 12usize],
    pub buttonCount: u8,
    pub povCount: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickDescriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickDescriptor>(),
        273usize,
        concat!("Size of: ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isXbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(isXbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axisCount) as usize - ptr as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axisTypes) as usize - ptr as usize },
        259usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttonCount) as usize - ptr as usize },
        271usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(buttonCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povCount) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(povCount)
        )
    );
}
impl Default for HAL_JoystickDescriptor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_MatchInfo {
    pub eventName: [::std::os::raw::c_char; 64usize],
    pub matchType: HAL_MatchType,
    pub matchNumber: u16,
    pub replayNumber: u8,
    pub gameSpecificMessage: [u8; 64usize],
    pub gameSpecificMessageSize: u16,
}
#[test]
fn bindgen_test_layout_HAL_MatchInfo() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_MatchInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_MatchInfo>(),
        140usize,
        concat!("Size of: ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_MatchInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(eventName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matchType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matchNumber) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replayNumber) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(replayNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessage) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessageSize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessageSize)
        )
    );
}
impl Default for HAL_MatchInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Sends an error to the driver station.\n\n @param isError   true for error, false for warning\n @param errorCode the error code\n @param isLVCode  true for a LV error code, false for a standard error code\n @param details   the details of the error\n @param location  the file location of the error\n @param callStack the callstack of the error\n @param printMsg  true to print the error message to stdout as well as to the\n DS\n @return the error code, or 0 for success"]
    pub fn HAL_SendError(
        isError: HAL_Bool,
        errorCode: i32,
        isLVCode: HAL_Bool,
        details: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
        callStack: *const ::std::os::raw::c_char,
        printMsg: HAL_Bool,
    ) -> i32;
}
extern "C" {
    #[doc = " Set the print function used by HAL_SendError\n\n @param func Function called by HAL_SendError when stderr is printed"]
    pub fn HAL_SetPrintErrorImpl(
        func: ::std::option::Option<
            unsafe extern "C" fn(line: *const ::std::os::raw::c_char, size: usize),
        >,
    );
}
extern "C" {
    #[doc = " Sends a line to the driver station console.\n\n @param line the line to send (null terminated)\n @return the error code, or 0 for success"]
    pub fn HAL_SendConsoleLine(line: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " Gets the current control word of the driver station.\n\n The control word contains the robot state.\n\n @param controlWord the control word (out)\n @return the error code, or 0 for success"]
    pub fn HAL_GetControlWord(controlWord: *mut HAL_ControlWord) -> i32;
}
extern "C" {
    #[doc = " Gets the current alliance station ID.\n\n @param[out] status the error code, or 0 for success\n @return the alliance station ID"]
    pub fn HAL_GetAllianceStation(status: *mut i32) -> HAL_AllianceStationID;
}
extern "C" {
    #[doc = " Gets the axes of a specific joystick.\n\n @param joystickNum the joystick number\n @param axes        the axes values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickAxes(joystickNum: i32, axes: *mut HAL_JoystickAxes) -> i32;
}
extern "C" {
    #[doc = " Gets the POVs of a specific joystick.\n\n @param joystickNum the joystick number\n @param povs        the POV values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickPOVs(joystickNum: i32, povs: *mut HAL_JoystickPOVs) -> i32;
}
extern "C" {
    #[doc = " Gets the buttons of a specific joystick.\n\n @param joystickNum the joystick number\n @param buttons     the button values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickButtons(joystickNum: i32, buttons: *mut HAL_JoystickButtons) -> i32;
}
extern "C" {
    pub fn HAL_GetAllJoystickData(
        axes: *mut HAL_JoystickAxes,
        povs: *mut HAL_JoystickPOVs,
        buttons: *mut HAL_JoystickButtons,
    );
}
extern "C" {
    #[doc = " Retrieves the Joystick Descriptor for particular slot.\n\n @param joystickNum the joystick number\n @param[out] desc   descriptor (data transfer object) to fill in. desc is\n                    filled in regardless of success. In other words, if\n                    descriptor is not available, desc is filled in with\n                    default values matching the init-values in Java and C++\n                    Driver Station for when caller requests a too-large\n                    joystick index.\n @return error code reported from Network Comm back-end.  Zero is good,\n         nonzero is bad."]
    pub fn HAL_GetJoystickDescriptor(joystickNum: i32, desc: *mut HAL_JoystickDescriptor) -> i32;
}
extern "C" {
    #[doc = " Gets whether a specific joystick is considered to be an XBox controller.\n\n @param joystickNum the joystick number\n @return true if xbox, false otherwise"]
    pub fn HAL_GetJoystickIsXbox(joystickNum: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the type of joystick connected.\n\n This is device specific, and different depending on what system input type\n the joystick uses.\n\n @param joystickNum the joystick number\n @return the enumerated joystick type"]
    pub fn HAL_GetJoystickType(joystickNum: i32) -> i32;
}
extern "C" {
    #[doc = " Gets the name of a joystick.\n\n The returned string must be freed with WPI_FreeString\n\n @param name the joystick name string\n @param joystickNum the joystick number"]
    pub fn HAL_GetJoystickName(name: *mut WPI_String, joystickNum: i32);
}
extern "C" {
    #[doc = " Gets the type of a specific joystick axis.\n\n This is device specific, and different depending on what system input type\n the joystick uses.\n\n @param joystickNum the joystick number\n @param axis        the axis number\n @return the enumerated axis type"]
    pub fn HAL_GetJoystickAxisType(joystickNum: i32, axis: i32) -> i32;
}
extern "C" {
    #[doc = " Set joystick outputs.\n\n @param joystickNum the joystick number\n @param outputs     bitmask of outputs, 1 for on 0 for off\n @param leftRumble  the left rumble value (0-FFFF)\n @param rightRumble the right rumble value (0-FFFF)\n @return the error code, or 0 for success"]
    pub fn HAL_SetJoystickOutputs(
        joystickNum: i32,
        outputs: i64,
        leftRumble: i32,
        rightRumble: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Return the approximate match time. The FMS does not send an official match\n time to the robots, but does send an approximate match time. The value will\n count down the time remaining in the current period (auto or teleop).\n Warning: This is not an official time (so it cannot be used to dispute ref\n calls or guarantee that a function will trigger before the match ends).\n\n <p>When connected to the real field, this number only changes in full integer\n increments, and always counts down.\n\n <p>When the DS is in practice mode, this number is a floating point number,\n and counts down.\n\n <p>When the DS is in teleop or autonomous mode, this number is a floating\n point number, and counts up.\n\n <p>Simulation matches DS behavior without an FMS connected.\n\n @param[out] status the error code, or 0 for success\n @return Time remaining in current match period (auto or teleop) in seconds"]
    pub fn HAL_GetMatchTime(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets if outputs are enabled by the control system.\n\n @return true if outputs are enabled"]
    pub fn HAL_GetOutputsEnabled() -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets info about a specific match.\n\n @param[in] info the match info (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetMatchInfo(info: *mut HAL_MatchInfo) -> i32;
}
extern "C" {
    #[doc = " Refresh the DS control word.\n\n @return true if updated"]
    pub fn HAL_RefreshDSData() -> HAL_Bool;
}
extern "C" {
    pub fn HAL_ProvideNewDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    pub fn HAL_RemoveNewDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets the program starting flag in the DS.\n\n This is what changes the DS to showing robot code ready."]
    pub fn HAL_ObserveUserProgramStarting();
}
extern "C" {
    #[doc = " Sets the disabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramDisabled();
}
extern "C" {
    #[doc = " Sets the autonomous enabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramAutonomous();
}
extern "C" {
    #[doc = " Sets the teleoperated enabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramTeleop();
}
extern "C" {
    #[doc = " Sets the test mode flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramTest();
}
#[repr(i32)]
#[doc = " The type of index pulse for the encoder."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_EncoderIndexingType {
    HAL_kResetWhileHigh = 0,
    HAL_kResetWhileLow = 1,
    HAL_kResetOnFallingEdge = 2,
    HAL_kResetOnRisingEdge = 3,
}
#[repr(i32)]
#[doc = " The encoding scaling of the encoder."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_EncoderEncodingType {
    HAL_Encoder_k1X = 0,
    HAL_Encoder_k2X = 1,
    HAL_Encoder_k4X = 2,
}
extern "C" {
    #[doc = " Initializes an encoder.\n\n @param[in] digitalSourceHandleA the A source (either a HAL_DigitalHandle or a\n                                 HAL_AnalogTriggerHandle)\n @param[in] analogTriggerTypeA   the analog trigger type of the A source if it\n                                 is an analog trigger\n @param[in] digitalSourceHandleB the B source (either a HAL_DigitalHandle or a\n                                 HAL_AnalogTriggerHandle)\n @param[in] analogTriggerTypeB   the analog trigger type of the B source if it\n                                 is an analog trigger\n @param[in] reverseDirection     true to reverse the counting direction from\n                                 standard, otherwise false\n @param[in] encodingType         the encoding type\n @param[out] status              Error status variable. 0 on success.\n @return the created encoder handle"]
    pub fn HAL_InitializeEncoder(
        digitalSourceHandleA: HAL_Handle,
        analogTriggerTypeA: HAL_AnalogTriggerType,
        digitalSourceHandleB: HAL_Handle,
        analogTriggerTypeB: HAL_AnalogTriggerType,
        reverseDirection: HAL_Bool,
        encodingType: HAL_EncoderEncodingType,
        status: *mut i32,
    ) -> HAL_EncoderHandle;
}
extern "C" {
    #[doc = " Frees an encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_FreeEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Indicates the encoder is used by a simulated device.\n\n @param handle the encoder handle\n @param device simulated device handle"]
    pub fn HAL_SetEncoderSimDevice(handle: HAL_EncoderHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Gets the current counts of the encoder after encoding type scaling.\n\n This is scaled by the value passed during initialization to encodingType.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success.\n @return the current scaled count"]
    pub fn HAL_GetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the raw counts of the encoder.\n\n This is not scaled by any values.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success.\n @return the raw encoder count"]
    pub fn HAL_GetEncoderRaw(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the encoder scale value.\n\n This is set by the value passed during initialization to encodingType.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder scale value"]
    pub fn HAL_GetEncoderEncodingScale(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Reads the current encoder value.\n\n Read the value at this instant. It may still be running, so it reflects the\n current value. Next time it is read, it might have a different value.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ResetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the Period of the most recent count.\n\n Returns the time interval of the most recent count. This can be used for\n velocity calculations to determine shaft speed.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @returns the period of the last two pulses in units of seconds"]
    pub fn HAL_GetEncoderPeriod(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the maximum period where the device is still considered \"moving\".\n\n Sets the maximum period where the device is considered moving. This value is\n used to determine the \"stopped\" state of the encoder using the\n HAL_GetEncoderStopped method.\n\n @param[in] encoderHandle the encoder handle\n @param[in] maxPeriod     the maximum period where the counted device is\n                          considered moving in seconds\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetEncoderMaxPeriod(
        encoderHandle: HAL_EncoderHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Determines if the clock is stopped.\n\n Determines if the clocked input is stopped based on the MaxPeriod value set\n using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n device (and encoder) are assumed to be stopped and it returns true.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return true if the most recent encoder period exceeds the MaxPeriod value\n         set by SetMaxPeriod"]
    pub fn HAL_GetEncoderStopped(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the last direction the encoder value changed.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the last direction the encoder value changed"]
    pub fn HAL_GetEncoderDirection(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the current distance traveled by the encoder.\n\n This is the encoder count scaled by the distance per pulse set for the\n encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder distance (units are determined by the units\n                      passed to HAL_SetEncoderDistancePerPulse)"]
    pub fn HAL_GetEncoderDistance(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the current rate of the encoder.\n\n This is the encoder period scaled by the distance per pulse set for the\n encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder rate (units are determined by the units passed to\n         HAL_SetEncoderDistancePerPulse, time value is seconds)"]
    pub fn HAL_GetEncoderRate(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the minimum rate to be considered moving by the encoder.\n\n Units need to match what is set by HAL_SetEncoderDistancePerPulse, with time\n as seconds.\n\n @param[in] encoderHandle the encoder handle\n @param[in] minRate       the minimum rate to be considered moving (units are\n                          determined by the units passed to\n                          HAL_SetEncoderDistancePerPulse, time value is\n                          seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetEncoderMinRate(encoderHandle: HAL_EncoderHandle, minRate: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the distance traveled per encoder pulse. This is used as a scaling\n factor for the rate and distance calls.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] distancePerPulse the distance traveled per encoder pulse (units\n                             user defined)\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        distancePerPulse: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets if to reverse the direction of the encoder.\n\n Note that this is not a toggle. It is an absolute set.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] reverseDirection true to reverse the direction, false to not.\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderReverseDirection(
        encoderHandle: HAL_EncoderHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the number of encoder samples to average when calculating encoder rate.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] samplesToAverage the number of samples to average\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current samples to average value.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the current samples to average value"]
    pub fn HAL_GetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the source for an index pulse on the encoder.\n\n The index pulse can be used to cause an encoder to reset based on an external\n input.\n\n @param[in] encoderHandle       the encoder handle\n @param[in] digitalSourceHandle the index source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[in] type                the index triggering type\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetEncoderIndexSource(
        encoderHandle: HAL_EncoderHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        type_: HAL_EncoderIndexingType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the FPGA index of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the FPGA index of the encoder"]
    pub fn HAL_GetEncoderFPGAIndex(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the decoding scale factor of the encoder.\n\n This is used to perform the scaling from raw to type scaled values.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the scale value for the encoder"]
    pub fn HAL_GetEncoderDecodingScaleFactor(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the user set distance per pulse of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the set distance per pulse"]
    pub fn HAL_GetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the encoding type of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoding type"]
    pub fn HAL_GetEncoderEncodingType(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> HAL_EncoderEncodingType;
}
extern "C" {
    #[doc = " Reports a hardware usage to the HAL.\n\n @param resource       the used resource\n @param instanceNumber the instance of the resource\n @param context        a user specified context index\n @param feature        a user specified feature string\n @return               the index of the added value in NetComm"]
    pub fn HAL_Report(
        resource: i32,
        instanceNumber: i32,
        context: i32,
        feature: *const ::std::os::raw::c_char,
    ) -> i64;
}
#[repr(i32)]
#[doc = " @defgroup hal_capi WPILib HAL API\n Hardware Abstraction Layer (HAL) to hardware or simulator\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_RuntimeType {
    HAL_Runtime_RoboRIO = 0,
    HAL_Runtime_RoboRIO2 = 1,
    HAL_Runtime_Simulation = 2,
}
extern "C" {
    #[doc = " Gets the last error set on this thread, or the message for the status code.\n\n If passed HAL_USE_LAST_ERROR, the last error set on the thread will be\n returned.\n\n @param[out] status the status code, set to the error status code if input is\n               HAL_USE_LAST_ERROR\n @return the error message for the code. This does not need to be freed,\n               but can be overwritten by another hal call on the same thread."]
    pub fn HAL_GetLastError(status: *mut i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the error message for a specific status code.\n\n @param code the status code\n @return the error message for the code. This does not need to be freed."]
    pub fn HAL_GetErrorMessage(code: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the FPGA Version number.\n\n For now, expect this to be competition year.\n\n @param[out] status the error code, or 0 for success\n @return FPGA Version number."]
    pub fn HAL_GetFPGAVersion(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Returns the FPGA Revision number.\n\n The format of the revision is 3 numbers.\n The 12 most significant bits are the Major Revision.\n the next 8 bits are the Minor Revision.\n The 12 least significant bits are the Build Number.\n\n @param[out] status the error code, or 0 for success\n @return FPGA Revision number."]
    pub fn HAL_GetFPGARevision(status: *mut i32) -> i64;
}
extern "C" {
    #[doc = " Returns the roboRIO serial number.\n\n @param[out] serialNumber The roboRIO serial number. Free with WPI_FreeString"]
    pub fn HAL_GetSerialNumber(serialNumber: *mut WPI_String);
}
extern "C" {
    #[doc = " Returns the comments from the roboRIO web interface.\n\n @param[out] comments The comments string. Free with WPI_FreeString"]
    pub fn HAL_GetComments(comments: *mut WPI_String);
}
extern "C" {
    #[doc = " Returns the team number configured for the robot controller.\n @return team number, or 0 if not found."]
    pub fn HAL_GetTeamNumber() -> i32;
}
extern "C" {
    #[doc = " Returns the runtime type of the HAL.\n\n @return HAL Runtime Type"]
    pub fn HAL_GetRuntimeType() -> HAL_RuntimeType;
}
extern "C" {
    #[doc = " Gets the state of the \"USER\" button on the roboRIO.\n\n @warning the User Button is used to stop user programs from automatically\n loading if it is held for more then 5 seconds. Because of this, it's not\n recommended to be used by teams for any other purpose.\n\n @param[out] status the error code, or 0 for success\n @return true if the button is currently pressed down"]
    pub fn HAL_GetFPGAButton(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system outputs are currently active.\n\n @param[out] status the error code, or 0 for success\n @return true if the system outputs are active, false if disabled"]
    pub fn HAL_GetSystemActive(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system is in a browned out state.\n\n @param[out] status the error code, or 0 for success\n @return true if the system is in a low voltage brown out, false otherwise"]
    pub fn HAL_GetBrownedOut(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets a port handle for a specific channel.\n\n The created handle does not need to be freed.\n\n @param channel the channel number\n @return the created port"]
    pub fn HAL_GetPort(channel: i32) -> HAL_PortHandle;
}
extern "C" {
    #[doc = " Gets a port handle for a specific channel and module.\n\n This is expected to be used for PCMs, as the roboRIO does not work with\n modules anymore.\n\n The created handle does not need to be freed.\n\n @param module  the module number\n @param channel the channel number\n @return the created port"]
    pub fn HAL_GetPortWithModule(module: i32, channel: i32) -> HAL_PortHandle;
}
extern "C" {
    #[doc = " Reads the microsecond-resolution timer on the FPGA.\n\n @param[out] status the error code, or 0 for success\n @return The current time in microseconds according to the FPGA (since FPGA\n reset)."]
    pub fn HAL_GetFPGATime(status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Given an 32 bit FPGA time, expand it to the nearest likely 64 bit FPGA time.\n\n Note: This is making the assumption that the timestamp being converted is\n always in the past.  If you call this with a future timestamp, it probably\n will make it in the past.  If you wait over 70 minutes between capturing the\n bottom 32 bits of the timestamp and expanding it, you will be off by\n multiples of 1<<32 microseconds.\n\n @param[in] unexpandedLower 32 bit FPGA time\n @param[out] status the error code, or 0 for success\n @return The current time in microseconds according to the FPGA (since FPGA\n         reset) as a 64 bit number."]
    pub fn HAL_ExpandFPGATime(unexpandedLower: u32, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Gets the current state of the Robot Signal Light (RSL).\n\n @param[out] status the error code, or 0 for success\n @return The current state of the RSL- true if on, false if off"]
    pub fn HAL_GetRSLState(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system time is valid.\n\n @param[out] status the error code, or 0 for success\n @return True if the system time is valid, false otherwise"]
    pub fn HAL_GetSystemTimeValid(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Call this to start up HAL. This is required for robot programs.\n\n This must be called before any other HAL functions. Failure to do so will\n result in undefined behavior, and likely segmentation faults. This means that\n any statically initialized variables in a program MUST call this function in\n their constructors if they want to use other HAL calls.\n\n The common parameters are 500 for timeout and 0 for mode.\n\n This function is safe to call from any thread, and as many times as you wish.\n It internally guards from any reentrancy.\n\n The applicable modes are:\n   0: Try to kill an existing HAL from another program, if not successful,\n error.\n   1: Force kill a HAL from another program.\n   2: Just warn if another hal exists and cannot be killed. Will likely result\n in undefined behavior.\n\n @param timeout the initialization timeout (ms)\n @param mode    the initialization mode (see remarks)\n @return true if initialization was successful, otherwise false."]
    pub fn HAL_Initialize(timeout: i32, mode: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Call this to shut down HAL.\n\n This must be called at termination of the robot program to avoid potential\n segmentation faults with simulation extensions at exit."]
    pub fn HAL_Shutdown();
}
extern "C" {
    #[doc = " Calls registered SimPeriodic \"before\" callbacks (only in simulation mode).\n This should be called prior to user code periodic simulation functions."]
    pub fn HAL_SimPeriodicBefore();
}
extern "C" {
    #[doc = " Calls registered SimPeriodic \"after\" callbacks (only in simulation mode).\n This should be called after user code periodic simulation functions."]
    pub fn HAL_SimPeriodicAfter();
}
#[repr(i32)]
#[doc = " @defgroup hal_i2c I2C Functions\n @ingroup hal_capi\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_I2CPort {
    HAL_I2C_kInvalid = -1,
    HAL_I2C_kOnboard = 0,
    HAL_I2C_kMXP = 1,
}
extern "C" {
    #[doc = " Initializes the I2C port.\n\n Opens the port if necessary and saves the handle.\n If opening the MXP port, also sets up the channel functions appropriately.\n\n @param[in] port    The port to open, 0 for the on-board, 1 for the MXP.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_InitializeI2C(port: HAL_I2CPort, status: *mut i32);
}
extern "C" {
    #[doc = " Generic I2C read/write transaction.\n\n This is a lower-level interface to the I2C hardware giving you more control\n over each transaction.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The address of the register on the device to be\n                      read/written.\n @param dataToSend Buffer of data to send as part of the transaction.\n @param sendSize Number of bytes to send as part of the transaction.\n @param dataReceived Buffer to read data into.\n @param receiveSize Number of bytes to read from the device.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_TransactionI2C(
        port: HAL_I2CPort,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
        dataReceived: *mut u8,
        receiveSize: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a write transaction with the device.\n\n Writes a single byte to a register on a device and wait until the\n   transaction is complete.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The address of the register on the device to be\n                      written.\n @param dataToSend The byte to write to the register on the device.\n @param sendSize Number of bytes to send.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_WriteI2C(
        port: HAL_I2CPort,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a read transaction with the device.\n\n Reads bytes from a device.\n Most I2C devices will auto-increment the register pointer internally allowing\n   you to read consecutive registers on a device in a single transaction.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The register to read first in the transaction.\n @param count The number of bytes to read in the transaction.\n @param buffer A pointer to the array of bytes to store the data read from the\n device.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_ReadI2C(port: HAL_I2CPort, deviceAddress: i32, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    #[doc = " Closes an I2C port\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP."]
    pub fn HAL_CloseI2C(port: HAL_I2CPort);
}
extern "C" {
    #[doc = " Initializes an interrupt.\n\n @param[out] status Error status variable. 0 on success.\n @return the created interrupt handle"]
    pub fn HAL_InitializeInterrupts(status: *mut i32) -> HAL_InterruptHandle;
}
extern "C" {
    #[doc = " Frees an interrupt.\n\n @param interruptHandle the interrupt handle"]
    pub fn HAL_CleanInterrupts(interruptHandle: HAL_InterruptHandle);
}
extern "C" {
    #[doc = " Waits for the defined interrupt to occur.\n\n @param[in] interruptHandle the interrupt handle\n @param[in] timeout         timeout in seconds\n @param[in] ignorePrevious  if true, ignore interrupts that happened before\n                            waitForInterrupt was called\n @param[out] status         Error status variable. 0 on success.\n @return the mask of interrupts that fired"]
    pub fn HAL_WaitForInterrupt(
        interruptHandle: HAL_InterruptHandle,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Waits for any interrupt covered by the mask to occur.\n\n @param[in] interruptHandle the interrupt handle to use for the context\n @param[in] mask            the mask of interrupts to wait for\n @param[in] timeout         timeout in seconds\n @param[in] ignorePrevious  if true, ignore interrupts that happened before\n                            waitForInterrupt was called\n @param[out] status         Error status variable. 0 on success.\n @return the mask of interrupts that fired"]
    pub fn HAL_WaitForMultipleInterrupts(
        interruptHandle: HAL_InterruptHandle,
        mask: i64,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for the rising interrupt that occurred most recently.\n\n This is in the same time domain as HAL_GetFPGATime().  It only contains the\n bottom 32 bits of the timestamp.  If your robot has been running for over 1\n hour, you will need to fill in the upper 32 bits yourself.\n\n @param[in] interruptHandle the interrupt handle\n @param[out] status         Error status variable. 0 on success.\n @return timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_ReadInterruptRisingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for the falling interrupt that occurred most recently.\n\n This is in the same time domain as HAL_GetFPGATime().  It only contains the\n bottom 32 bits of the timestamp.  If your robot has been running for over 1\n hour, you will need to fill in the upper 32 bits yourself.\n\n @param[in] interruptHandle the interrupt handle\n @param[out] status         Error status variable. 0 on success.\n @return timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_ReadInterruptFallingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Requests interrupts on a specific digital source.\n\n @param[in] interruptHandle     the interrupt handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the trigger type if the source is an\n                                AnalogTrigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_RequestInterrupts(
        interruptHandle: HAL_InterruptHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the edges to trigger the interrupt on.\n\n Note that both edges triggered is a valid configuration.\n\n @param[in] interruptHandle the interrupt handle\n @param[in] risingEdge      true for triggering on rising edge\n @param[in] fallingEdge     true for triggering on falling edge\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_SetInterruptUpSourceEdge(
        interruptHandle: HAL_InterruptHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Releases a waiting interrupt.\n\n This will release both rising and falling waiters.\n\n @param[in] interruptHandle the interrupt handle to release\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_ReleaseWaitingInterrupt(interruptHandle: HAL_InterruptHandle, status: *mut i32);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_RadioLEDState {
    HAL_RadioLED_kOff = 0,
    HAL_RadioLED_kGreen = 1,
    HAL_RadioLED_kRed = 2,
    HAL_RadioLED_kOrange = 3,
}
extern "C" {
    #[doc = " Set the state of the \"Radio\" LED.\n @param state The state to set the LED to.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetRadioLEDState(state: HAL_RadioLEDState, status: *mut i32);
}
extern "C" {
    #[doc = " Get the state of the \"Radio\" LED.\n\n @param[out] status the error code, or 0 for success\n @return The state of the LED."]
    pub fn HAL_GetRadioLEDState(status: *mut i32) -> HAL_RadioLEDState;
}
extern "C" {
    #[doc = " Sets up the system to run the provided main loop in the main thread (e.g.\n the thread in which main() starts execution) and run the robot code in a\n separate thread.\n\n Normally the robot code runs in the main thread, but some GUI systems\n require the GUI be run in the main thread.\n\n To be effective, this function must be called before the robot code starts\n the main loop (e.g. by frc::StartRobot()).\n\n @param param parameter data to pass to mainFunc and exitFunc\n @param mainFunc the function to be run when HAL_RunMain() is called.\n @param exitFunc the function to be run when HAL_ExitMain() is called."]
    pub fn HAL_SetMain(
        param: *mut ::std::os::raw::c_void,
        mainFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        exitFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " Returns true if HAL_SetMain() has been called.\n\n @return True if HAL_SetMain() has been called, false otherwise."]
    pub fn HAL_HasMain() -> HAL_Bool;
}
extern "C" {
    #[doc = " Runs the main function provided to HAL_SetMain().\n\n If HAL_SetMain() has not been called, simply sleeps until HAL_ExitMain()\n is called."]
    pub fn HAL_RunMain();
}
extern "C" {
    #[doc = " Causes HAL_RunMain() to exit.\n\n If HAL_SetMain() has been called, this calls the exit function provided\n to that function."]
    pub fn HAL_ExitMain();
}
extern "C" {
    #[doc = " Initializes a notifier.\n\n A notifier is an FPGA controller timer that triggers at requested intervals\n based on the FPGA time. This can be used to make precise control loops.\n\n @param[out] status Error status variable. 0 on success.\n @return the created notifier"]
    pub fn HAL_InitializeNotifier(status: *mut i32) -> HAL_NotifierHandle;
}
extern "C" {
    #[doc = " Sets the HAL notifier thread priority.\n\n The HAL notifier thread is responsible for managing the FPGA's notifier\n interrupt and waking up user's Notifiers when it's their time to run.\n Giving the HAL notifier thread real-time priority helps ensure the user's\n real-time Notifiers, if any, are notified to run in a timely manner.\n\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetNotifierThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the name of a notifier.\n\n @param[in] notifierHandle the notifier handle\n @param[in] name name\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetNotifierName(
        notifierHandle: HAL_NotifierHandle,
        name: *const ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Stops a notifier from running.\n\n This will cause any call into HAL_WaitForNotifierAlarm to return with time =\n 0.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_StopNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Cleans a notifier.\n\n Note this also stops a notifier if it is already running.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CleanNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Updates the trigger time for a notifier.\n\n Note that this time is an absolute time relative to HAL_GetFPGATime()\n\n @param[in] notifierHandle the notifier handle\n @param[in] triggerTime    the updated trigger time\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_UpdateNotifierAlarm(
        notifierHandle: HAL_NotifierHandle,
        triggerTime: u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Cancels the next notifier alarm.\n\n This does not cause HAL_WaitForNotifierAlarm to return.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CancelNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Waits for the next alarm for the specific notifier.\n\n This is a blocking call until either the time elapses or HAL_StopNotifier\n gets called. If the latter occurs, this function will return zero and any\n loops using this function should exit. Failing to do so can lead to\n use-after-frees.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status        Error status variable. 0 on success.\n @return the FPGA time the notifier returned"]
    pub fn HAL_WaitForNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Initializes a PWM port.\n\n @param[in] portHandle the port to initialize\n @param[in] allocationLocation  the location where the allocation is occurring\n                                (can be null)\n @param[out] status             Error status variable. 0 on success.\n @return the created pwm handle"]
    pub fn HAL_InitializePWMPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    #[doc = " Frees a PWM port.\n\n @param[in] pwmPortHandle the pwm handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_FreePWMPort(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Checks if a pwm channel is valid.\n\n @param channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckPWMChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the configuration settings for the PWM channel.\n\n All values are in microseconds.\n\n @param[in] pwmPortHandle  the PWM handle\n @param[in] maxPwm         the maximum PWM value\n @param[in] deadbandMaxPwm the high range of the center deadband\n @param[in] centerPwm      the center PWM value\n @param[in] deadbandMinPwm the low range of the center deadband\n @param[in] minPwm         the minimum PWM value\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetPWMConfigMicroseconds(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: i32,
        deadbandMaxPwm: i32,
        centerPwm: i32,
        deadbandMinPwm: i32,
        minPwm: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the pwm configuration settings for the PWM channel.\n\n Values are in microseconds.\n\n @param[in] pwmPortHandle  the PWM handle\n @param[in] maxPwm         the maximum PWM value\n @param[in] deadbandMaxPwm the high range of the center deadband\n @param[in] centerPwm      the center PWM value\n @param[in] deadbandMinPwm the low range of the center deadband\n @param[in] minPwm         the minimum PWM value\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_GetPWMConfigMicroseconds(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: *mut i32,
        deadbandMaxPwm: *mut i32,
        centerPwm: *mut i32,
        deadbandMinPwm: *mut i32,
        minPwm: *mut i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets if the FPGA should output the center value if the input value is within\n the deadband.\n\n @param[in] pwmPortHandle     the PWM handle\n @param[in] eliminateDeadband true to eliminate deadband, otherwise false\n @param[out] status           Error status variable. 0 on success."]
    pub fn HAL_SetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        eliminateDeadband: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current eliminate deadband value.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return true if set, otherwise false"]
    pub fn HAL_GetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired pulse width in microseconds.\n\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] microsecondPulseTime  the PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMPulseTimeMicroseconds(
        pwmPortHandle: HAL_DigitalHandle,
        microsecondPulseTime: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired scaled value.\n\n The values range from -1 to 1 and the period is controlled by the PWM Period\n and MinHigh registers.\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] speed         the scaled PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, speed: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired position value.\n\n The values range from 0 to 1 and the period is controlled by the PWM Period\n and MinHigh registers.\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] position      the positional PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMPosition(pwmPortHandle: HAL_DigitalHandle, position: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to be disabled.\n\n The channel is disabled until the next time it is set. Note this is different\n from just setting a 0 speed, as this will actively stop all signaling on the\n channel.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMDisabled(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current microsecond pulse time from a PWM channel.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current PWM microsecond pulse time"]
    pub fn HAL_GetPWMPulseTimeMicroseconds(
        pwmPortHandle: HAL_DigitalHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a scaled value from a PWM channel.\n\n The values range from -1 to 1.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current speed PWM value"]
    pub fn HAL_GetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets a position value from a PWM channel.\n\n The values range from 0 to 1.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current positional PWM value"]
    pub fn HAL_GetPWMPosition(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Forces a PWM signal to go to 0 temporarily.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_LatchPWMZero(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets how how often the PWM signal is squelched, thus scaling the period.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[in] squelchMask   the 2-bit mask of outputs to squelch\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMPeriodScale(
        pwmPortHandle: HAL_DigitalHandle,
        squelchMask: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the PWM output to be a continuous high signal while enabled.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMAlwaysHighMode(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the loop timing of the PWM system.\n\n @param[out] status Error status variable. 0 on success.\n @return the loop time"]
    pub fn HAL_GetPWMLoopTiming(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the pwm starting cycle time.\n\n This time is relative to the FPGA time.\n\n @param[out] status Error status variable. 0 on success.\n @return the pwm cycle start time"]
    pub fn HAL_GetPWMCycleStartTime(status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Gets the number of analog accumulators in the current system.\n\n @return the number of analog accumulators"]
    pub fn HAL_GetNumAccumulators() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog triggers in the current system.\n\n @return the number of analog triggers"]
    pub fn HAL_GetNumAnalogTriggers() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog inputs in the current system.\n\n @return the number of analog inputs"]
    pub fn HAL_GetNumAnalogInputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog outputs in the current system.\n\n @return the number of analog outputs"]
    pub fn HAL_GetNumAnalogOutputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of counters in the current system.\n\n @return the number of counters"]
    pub fn HAL_GetNumCounters() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital headers in the current system.\n\n @return the number of digital headers"]
    pub fn HAL_GetNumDigitalHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PWM headers in the current system.\n\n @return the number of PWM headers"]
    pub fn HAL_GetNumPWMHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital channels in the current system.\n\n @return the number of digital channels"]
    pub fn HAL_GetNumDigitalChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PWM channels in the current system.\n\n @return the number of PWM channels"]
    pub fn HAL_GetNumPWMChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital IO PWM outputs in the current system.\n\n @return the number of digital IO PWM outputs"]
    pub fn HAL_GetNumDigitalPWMOutputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of quadrature encoders in the current system.\n\n @return the number of quadrature encoders"]
    pub fn HAL_GetNumEncoders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of interrupts in the current system.\n\n @return the number of interrupts"]
    pub fn HAL_GetNumInterrupts() -> i32;
}
extern "C" {
    #[doc = " Gets the number of relay channels in the current system.\n\n @return the number of relay channels"]
    pub fn HAL_GetNumRelayChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of relay headers in the current system.\n\n @return the number of relay headers"]
    pub fn HAL_GetNumRelayHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PCM modules in the current system.\n\n @return the number of PCM modules"]
    pub fn HAL_GetNumCTREPCMModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of solenoid channels in the current system.\n\n @return the number of solenoid channels"]
    pub fn HAL_GetNumCTRESolenoidChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDP modules in the current system.\n\n @return the number of PDP modules"]
    pub fn HAL_GetNumCTREPDPModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDP channels in the current system.\n\n @return the number of PDP channels"]
    pub fn HAL_GetNumCTREPDPChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDH modules in the current system.\n\n @return the number of PDH modules"]
    pub fn HAL_GetNumREVPDHModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDH channels in the current system.\n\n @return the number of PDH channels"]
    pub fn HAL_GetNumREVPDHChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PH modules in the current system.\n\n @return the number of PH modules"]
    pub fn HAL_GetNumREVPHModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PH channels in the current system.\n\n @return the number of PH channels"]
    pub fn HAL_GetNumREVPHChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of duty cycle inputs in the current system.\n\n @return the number of Duty Cycle inputs"]
    pub fn HAL_GetNumDutyCycles() -> i32;
}
extern "C" {
    #[doc = " Gets the number of addressable LED generators in the current system.\n\n @return the number of Addressable LED generators"]
    pub fn HAL_GetNumAddressableLEDs() -> i32;
}
extern "C" {
    #[doc = " Gets the roboRIO input voltage.\n\n @param[out] status the error code, or 0 for success\n @return the input voltage (volts)"]
    pub fn HAL_GetVinVoltage(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the roboRIO input current.\n\n @param[out] status the error code, or 0 for success\n @return the input current (amps)"]
    pub fn HAL_GetVinCurrent(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 6V rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 6V rail voltage (volts)"]
    pub fn HAL_GetUserVoltage6V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 6V rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 6V rail current (amps)"]
    pub fn HAL_GetUserCurrent6V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 6V rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive6V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 6V rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 6V fault counts"]
    pub fn HAL_GetUserCurrentFaults6V(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Enables or disables the 6V rail.\n\n @param enabled whether the rail should be enabled\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetUserRailEnabled6V(enabled: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the 5V rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 5V rail voltage (volts)"]
    pub fn HAL_GetUserVoltage5V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 5V rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 5V rail current (amps)"]
    pub fn HAL_GetUserCurrent5V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 5V rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive5V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 5V rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 5V fault counts"]
    pub fn HAL_GetUserCurrentFaults5V(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Enables or disables the 5V rail.\n\n @param enabled whether the rail should be enabled\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetUserRailEnabled5V(enabled: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the 3V3 rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 3V3 rail voltage (volts)"]
    pub fn HAL_GetUserVoltage3V3(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 3V3 rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 3V3 rail current (amps)"]
    pub fn HAL_GetUserCurrent3V3(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 3V3 rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive3V3(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 3V3 rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 3V3 fault counts"]
    pub fn HAL_GetUserCurrentFaults3V3(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Enables or disables the 3V3 rail.\n\n @param enabled whether the rail should be enabled\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetUserRailEnabled3V3(enabled: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Get the current brownout voltage setting.\n\n @param[out] status the error code, or 0 for success\n @return The brownout voltage"]
    pub fn HAL_GetBrownoutVoltage(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Set the voltage the roboRIO will brownout and disable all outputs.\n\n Note that this only does anything on the roboRIO 2.\n On the roboRIO it is a no-op.\n\n @param[in] voltage The brownout voltage\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetBrownoutVoltage(voltage: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Get the current CPU temperature in degrees Celsius\n\n @param[out] status the error code, or 0 for success\n @return current CPU temperature in degrees Celsius"]
    pub fn HAL_GetCPUTemp(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Initializes a relay.\n\n Note this call will only initialize either the forward or reverse port of the\n relay. If you need both, you will need to initialize 2 relays.\n\n @param[in] portHandle         the port handle to initialize\n @param[in] fwd                true for the forward port, false for the\n                               reverse port\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status            Error status variable. 0 on success.\n @return the created relay handle"]
    pub fn HAL_InitializeRelayPort(
        portHandle: HAL_PortHandle,
        fwd: HAL_Bool,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_RelayHandle;
}
extern "C" {
    #[doc = " Frees a relay port.\n\n @param relayPortHandle the relay handle"]
    pub fn HAL_FreeRelayPort(relayPortHandle: HAL_RelayHandle);
}
extern "C" {
    #[doc = " Checks if a relay channel is valid.\n\n @param channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckRelayChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the state of a relay output.\n\n @param[in] relayPortHandle the relay handle\n @param[in] on              true for on, false for off\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_SetRelay(relayPortHandle: HAL_RelayHandle, on: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current state of the relay channel.\n\n @param[in] relayPortHandle the relay handle\n @param[out] status         Error status variable. 0 on success.\n @return true for on, false for off"]
    pub fn HAL_GetRelay(relayPortHandle: HAL_RelayHandle, status: *mut i32) -> HAL_Bool;
}
#[repr(i32)]
#[doc = " @defgroup hal_spi SPI Functions\n @ingroup hal_capi\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_SPIPort {
    HAL_SPI_kInvalid = -1,
    HAL_SPI_kOnboardCS0 = 0,
    HAL_SPI_kOnboardCS1 = 1,
    HAL_SPI_kOnboardCS2 = 2,
    HAL_SPI_kOnboardCS3 = 3,
    HAL_SPI_kMXP = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_SPIMode {
    HAL_SPI_kMode0 = 0,
    HAL_SPI_kMode1 = 1,
    HAL_SPI_kMode2 = 2,
    HAL_SPI_kMode3 = 3,
}
extern "C" {
    #[doc = " Initializes the SPI port. Opens the port if necessary and saves the handle.\n\n If opening the MXP port, also sets up the channel functions appropriately.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS3, 4\n                    for MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_InitializeSPI(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Performs an SPI send/receive transaction.\n\n This is a lower-level interface to the spi hardware giving you more control\n over each transaction.\n\n @param port         The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                     for MXP\n @param dataToSend   Buffer of data to send as part of the transaction.\n @param dataReceived Buffer to read data into.\n @param size         Number of bytes to transfer. [0..7]\n @return Number of bytes transferred, -1 for error"]
    pub fn HAL_TransactionSPI(
        port: HAL_SPIPort,
        dataToSend: *const u8,
        dataReceived: *mut u8,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a write transaction with the device.\n\n Writes to a device and wait until the transaction is complete.\n\n @param port       The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                   for MXP\n @param dataToSend The data to write to the register on the device.\n @param sendSize   The number of bytes to be written\n @return The number of bytes written. -1 for an error"]
    pub fn HAL_WriteSPI(port: HAL_SPIPort, dataToSend: *const u8, sendSize: i32) -> i32;
}
extern "C" {
    #[doc = " Executes a read from the device.\n\n This method does not write any data out to the device.\n\n Most spi devices will require a register address to be written before they\n begin returning data.\n\n @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n               MXP\n @param buffer A pointer to the array of bytes to store the data read from the\n               device.\n @param count  The number of bytes to read in the transaction. [1..7]\n @return Number of bytes read. -1 for error."]
    pub fn HAL_ReadSPI(port: HAL_SPIPort, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    #[doc = " Closes the SPI port.\n\n @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP"]
    pub fn HAL_CloseSPI(port: HAL_SPIPort);
}
extern "C" {
    #[doc = " Sets the clock speed for the SPI bus.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n              MXP\n @param speed The speed in Hz (500KHz-10MHz)"]
    pub fn HAL_SetSPISpeed(port: HAL_SPIPort, speed: i32);
}
extern "C" {
    #[doc = " Sets the SPI Mode.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n MXP\n @param mode  The SPI mode to use"]
    pub fn HAL_SetSPIMode(port: HAL_SPIPort, mode: HAL_SPIMode);
}
extern "C" {
    #[doc = " Gets the SPI Mode.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n MXP\n @return      The SPI mode currently set"]
    pub fn HAL_GetSPIMode(port: HAL_SPIPort) -> HAL_SPIMode;
}
extern "C" {
    #[doc = " Sets the CS Active high for a SPI port.\n\n @param[in] port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n                 MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSPIChipSelectActiveHigh(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the CS Active low for a SPI port.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSPIChipSelectActiveLow(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the stored handle for a SPI port.\n\n @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP\n @return The stored handle for the SPI port. 0 represents no stored\n         handle."]
    pub fn HAL_GetSPIHandle(port: HAL_SPIPort) -> i32;
}
extern "C" {
    #[doc = " Sets the stored handle for a SPI port.\n\n @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n               MXP.\n @param handle The value of the handle for the port."]
    pub fn HAL_SetSPIHandle(port: HAL_SPIPort, handle: i32);
}
extern "C" {
    #[doc = " Initializes the SPI automatic accumulator.\n\n @param[in] port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n                       4 for MXP.\n @param[in] bufferSize The accumulator buffer size.\n @param[out] status    the error code, or 0 for success"]
    pub fn HAL_InitSPIAuto(port: HAL_SPIPort, bufferSize: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Frees an SPI automatic accumulator.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_FreeSPIAuto(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the period for automatic SPI accumulation.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[in] period  The accumulation period (seconds).\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_StartSPIAutoRate(port: HAL_SPIPort, period: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Starts the auto SPI accumulator on a specific trigger.\n\n Note that triggering on both rising and falling edges is a valid\n configuration.\n\n @param[in] port                The number of the port to use. 0-3 for Onboard\n                                CS0-CS2, 4 for MXP.\n @param[in] digitalSourceHandle The trigger source to use (Either\n                                HAL_AnalogTriggerHandle or HAL_DigitalHandle).\n @param[in] analogTriggerType   The analog trigger type, if the source is an\n                                analog trigger.\n @param[in] triggerRising       Trigger on the rising edge if true.\n @param[in] triggerFalling      Trigger on the falling edge if true.\n @param[out] status             the error code, or 0 for success"]
    pub fn HAL_StartSPIAutoTrigger(
        port: HAL_SPIPort,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        triggerRising: HAL_Bool,
        triggerFalling: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Stops an automatic SPI accumulation.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_StopSPIAuto(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the data to be transmitted to the device to initiate a read.\n\n @param[in] port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n                       4 for MXP.\n @param[in] dataToSend Pointer to the data to send (Gets copied for continue\n                       use, so no need to keep alive).\n @param[in] dataSize   The length of the data to send.\n @param[in] zeroSize   The number of zeros to send after the data.\n @param[out] status    the error code, or 0 for success"]
    pub fn HAL_SetSPIAutoTransmitData(
        port: HAL_SPIPort,
        dataToSend: *const u8,
        dataSize: i32,
        zeroSize: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Immediately forces an SPI read to happen.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ForceSPIAutoRead(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Reads data received by the SPI accumulator.  Each received data sequence\n consists of a timestamp followed by the received data bytes, one byte per\n word (in the least significant byte).  The length of each received data\n sequence is the same as the combined dataSize + zeroSize set in\n HAL_SetSPIAutoTransmitData.\n\n @param[in] port      The number of the port to use. 0-3 for Onboard CS0-CS2,\n                      4 for MXP.\n @param[out] buffer   The buffer to store the data into.\n @param[in] numToRead The number of words to read.\n @param[in] timeout   The read timeout (in seconds).\n @param[out] status   the error code, or 0 for success\n @return The number of words actually read."]
    pub fn HAL_ReadSPIAutoReceivedData(
        port: HAL_SPIPort,
        buffer: *mut u32,
        numToRead: i32,
        timeout: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the count of how many SPI accumulations have been missed.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success\n @return The number of missed accumulations."]
    pub fn HAL_GetSPIAutoDroppedCount(port: HAL_SPIPort, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Configure the Auto SPI Stall time between reads.\n\n @param[in] port             The number of the port to use. 0-3 for Onboard\n                             CS0-CS2, 4 for MXP.\n @param[in] csToSclkTicks    the number of ticks to wait before asserting the\n                             cs pin\n @param[in] stallTicks       the number of ticks to stall for\n @param[in] pow2BytesPerRead the number of bytes to read before stalling\n @param[out] status          the error code, or 0 for success"]
    pub fn HAL_ConfigureSPIAutoStall(
        port: HAL_SPIPort,
        csToSclkTicks: i32,
        stallTicks: i32,
        pow2BytesPerRead: i32,
        status: *mut i32,
    );
}
#[repr(i32)]
#[doc = " @defgroup hal_serialport Serial Port Functions\n @ingroup hal_capi\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_SerialPort {
    HAL_SerialPort_Onboard = 0,
    HAL_SerialPort_MXP = 1,
    HAL_SerialPort_USB1 = 2,
    HAL_SerialPort_USB2 = 3,
}
extern "C" {
    #[doc = " Initializes a serial port.\n\n The channels are either the onboard RS232, the MXP UART, or 2 USB ports. The\n top port is USB1, the bottom port is USB2.\n\n @param[in] port the serial port to initialize\n @param[out] status the error code, or 0 for success\n @return Serial Port Handle"]
    pub fn HAL_InitializeSerialPort(port: HAL_SerialPort, status: *mut i32)
        -> HAL_SerialPortHandle;
}
extern "C" {
    #[doc = " Initializes a serial port with a direct name.\n\n This name is the /dev name for a specific port.\n Note these are not always consistent between roboRIO reboots.\n\n @param[in] port     the serial port to initialize\n @param[in] portName the dev port name\n @param[out] status  the error code, or 0 for success\n @return Serial Port Handle"]
    pub fn HAL_InitializeSerialPortDirect(
        port: HAL_SerialPort,
        portName: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_SerialPortHandle;
}
extern "C" {
    #[doc = " Gets the raw serial port file descriptor from a handle.\n\n @param[in] handle the serial port handle\n @param[out] status the error code, or 0 for success\n @return the raw port descriptor"]
    pub fn HAL_GetSerialFD(handle: HAL_SerialPortHandle, status: *mut i32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the baud rate of a serial port.\n\n Any value between 0 and 0xFFFFFFFF may be used. Default is 9600.\n\n @param[in] handle  the serial port handle\n @param[in] baud    the baud rate to set\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialBaudRate(handle: HAL_SerialPortHandle, baud: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of data bits on a serial port.\n\n Defaults to 8.\n\n @param[in] handle  the serial port handle\n @param[in] bits    the number of data bits (5-8)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialDataBits(handle: HAL_SerialPortHandle, bits: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of parity bits on a serial port.\n\n Valid values are:\n   0: None (default)\n   1: Odd\n   2: Even\n   3: Mark - Means exists and always 1\n   4: Space - Means exists and always 0\n\n @param[in] handle  the serial port handle\n @param[in] parity  the parity bit mode (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialParity(handle: HAL_SerialPortHandle, parity: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of stop bits on a serial port.\n\n Valid values are:\n   10: One stop bit (default)\n   15: One and a half stop bits\n   20: Two stop bits\n\n @param[in] handle    the serial port handle\n @param[in] stopBits  the stop bit value (see remarks for valid values)\n @param[out] status   the error code, or 0 for success"]
    pub fn HAL_SetSerialStopBits(handle: HAL_SerialPortHandle, stopBits: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the write mode on a serial port.\n\n Valid values are:\n   1: Flush on access\n   2: Flush when full (default)\n\n @param[in] handle  the serial port handle\n @param[in] mode    the mode to set (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialWriteMode(handle: HAL_SerialPortHandle, mode: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the flow control mode of a serial port.\n\n Valid values are:\n   0: None (default)\n   1: XON-XOFF\n   2: RTS-CTS\n   3: DTR-DSR\n\n @param[in] handle  the serial port handle\n @param[in] flow    the mode to set (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialFlowControl(handle: HAL_SerialPortHandle, flow: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the minimum serial read timeout of a port.\n\n @param[in] handle   the serial port handle\n @param[in] timeout  the timeout in milliseconds\n @param[out] status  the error code, or 0 for success"]
    pub fn HAL_SetSerialTimeout(handle: HAL_SerialPortHandle, timeout: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the termination character that terminates a read.\n\n By default this is disabled.\n\n @param[in] handle      the serial port handle\n @param[in] terminator  the termination character to set\n @param[out] status     the error code, or 0 for success"]
    pub fn HAL_EnableSerialTermination(
        handle: HAL_SerialPortHandle,
        terminator: ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables a termination character for reads.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_DisableSerialTermination(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the size of the read buffer.\n\n @param[in] handle  the serial port handle\n @param[in] size    the read buffer size\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialReadBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the size of the write buffer.\n\n @param[in] handle  the serial port handle\n @param[in] size    the write buffer size\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialWriteBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the number of bytes currently in the read buffer.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success\n @return the number of bytes in the read buffer"]
    pub fn HAL_GetSerialBytesReceived(handle: HAL_SerialPortHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Reads data from the serial port.\n\n Will wait for either timeout (if set), the termination char (if set), or the\n count to be full. Whichever one comes first.\n\n @param[in] handle  the serial port handle\n @param[out] buffer the buffer in which to store bytes read\n @param[in] count   the number of bytes maximum to read\n @param[out] status the error code, or 0 for success\n @return the number of bytes actually read"]
    pub fn HAL_ReadSerial(
        handle: HAL_SerialPortHandle,
        buffer: *mut ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Writes data to the serial port.\n\n @param[in] handle  the serial port handle\n @param[in] buffer  the buffer to write\n @param[in] count   the number of bytes to write from the buffer\n @param[out] status the error code, or 0 for success\n @return the number of bytes actually written"]
    pub fn HAL_WriteSerial(
        handle: HAL_SerialPortHandle,
        buffer: *const ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Flushes the serial write buffer out to the port.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_FlushSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Clears the receive buffer of the serial port.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ClearSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Closes a serial port.\n\n @param[in] handle  the serial port handle to close\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_CloseSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
#[repr(u32)]
#[doc = " HAL data types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_Type {
    HAL_UNASSIGNED = 0,
    HAL_BOOLEAN = 1,
    HAL_DOUBLE = 2,
    HAL_ENUM = 4,
    HAL_INT = 8,
    HAL_LONG = 16,
}
#[doc = " HAL Entry Value.  Note this is a typed union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HAL_Value {
    pub data: HAL_Value__bindgen_ty_1,
    pub type_: HAL_Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HAL_Value__bindgen_ty_1 {
    pub v_boolean: HAL_Bool,
    pub v_enum: i32,
    pub v_int: i32,
    pub v_long: i64,
    pub v_double: f64,
}
#[test]
fn bindgen_test_layout_HAL_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_enum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_enum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
}
impl Default for HAL_Value__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_HAL_Value() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_Value>(),
        16usize,
        concat!("Size of: ", stringify!(HAL_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for HAL_Value {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " Direction of a simulated value (from the perspective of user code)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_SimValueDirection {
    #[doc = "< input to user code from the simulator"]
    HAL_SimValueInput = 0,
    #[doc = "< output from user code to the simulator"]
    HAL_SimValueOutput = 1,
    #[doc = "< bidirectional between user code and simulator"]
    HAL_SimValueBidir = 2,
}
extern "C" {
    #[doc = " Creates a simulated device.\n\n The device name must be unique.  0 is returned if the device name already\n exists.  If multiple instances of the same device are desired, recommend\n appending the instance/unique identifier in brackets to the base name,\n e.g. \"device[1]\".\n\n Using a device name of the form \"Type:Name\" will create a WebSockets node\n with a type value of \"Type\" and a device value of \"Name\"\n\n 0 is returned if not in simulation.\n\n @param name device name\n @return simulated device handle"]
    pub fn HAL_CreateSimDevice(name: *const ::std::os::raw::c_char) -> HAL_SimDeviceHandle;
}
extern "C" {
    #[doc = " Frees a simulated device.\n\n This also allows the same device name to be used again.\n This also frees all the simulated values created on the device.\n\n @param handle simulated device handle"]
    pub fn HAL_FreeSimDevice(handle: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Get the name of a simulated device\n\n @param handle simulated device handle\n @return name of the simulated device"]
    pub fn HAL_GetSimDeviceName(handle: HAL_SimDeviceHandle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a value on a simulated device.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param initialValue initial value\n @return simulated value handle"]
    pub fn HAL_CreateSimValue(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        initialValue: *const HAL_Value,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Creates an enumerated value on a simulated device.\n\n Enumerated values are always in the range 0 to numOptions-1.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param numOptions number of enumerated value options (length of options)\n @param options array of option descriptions\n @param initialValue initial value (selection)\n @return simulated value handle"]
    pub fn HAL_CreateSimValueEnum(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        numOptions: i32,
        options: *mut *const ::std::os::raw::c_char,
        initialValue: i32,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Creates an enumerated value on a simulated device with double values.\n\n Enumerated values are always in the range 0 to numOptions-1.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param numOptions number of enumerated value options (length of options)\n @param options array of option descriptions\n @param optionValues array of option double values\n @param initialValue initial value (selection)\n @return simulated value handle"]
    pub fn HAL_CreateSimValueEnumDouble(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        numOptions: i32,
        options: *mut *const ::std::os::raw::c_char,
        optionValues: *const f64,
        initialValue: i32,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Gets a simulated value.\n\n @param handle simulated value handle\n @param value value (output parameter)"]
    pub fn HAL_GetSimValue(handle: HAL_SimValueHandle, value: *mut HAL_Value);
}
extern "C" {
    #[doc = " Sets a simulated value.\n\n @param handle simulated value handle\n @param value the value to set"]
    pub fn HAL_SetSimValue(handle: HAL_SimValueHandle, value: *const HAL_Value);
}
extern "C" {
    #[doc = " Resets a simulated double or integral value to 0.\n Has no effect on other value types.\n Use this instead of Set(0) for resetting incremental sensor values like\n encoder counts or gyro accumulated angle to ensure correct behavior in a\n distributed system (e.g. WebSockets).\n\n @param handle simulated value handle"]
    pub fn HAL_ResetSimValue(handle: HAL_SimValueHandle);
}
#[doc = " @defgroup hal_threads Threads Functions\n @ingroup hal_capi\n @{"]
pub type NativeThreadHandle = *const ::std::os::raw::c_void;
extern "C" {
    #[doc = " Gets the thread priority for the specified thread.\n\n @param[in] handle      Native handle pointer to the thread to get the\n                        priority for.\n @param[out] isRealTime Set to true if thread is real-time, otherwise false.\n @param[out] status     Error status variable. 0 on success.\n @return The current thread priority. For real-time, this is 1-99 with 99\n         being highest. For non-real-time, this is 0. See \"man 7 sched\" for\n         details."]
    pub fn HAL_GetThreadPriority(
        handle: NativeThreadHandle,
        isRealTime: *mut HAL_Bool,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the thread priority for the current thread.\n\n @param[out] isRealTime Set to true if thread is real-time, otherwise false.\n @param[out] status     Error status variable. 0 on success.\n @return The current thread priority. For real-time, this is 1-99 with 99\n         being highest. For non-real-time, this is 0. See \"man 7 sched\" for\n         details."]
    pub fn HAL_GetCurrentThreadPriority(isRealTime: *mut HAL_Bool, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets the thread priority for the specified thread.\n\n @param[in] handle   Reference to the thread to set the priority of.\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetThreadPriority(
        handle: NativeThreadHandle,
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the thread priority for the current thread.\n\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetCurrentThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPI_DataLog {
    _unused: [u8; 0],
}
#[doc = " Typedefs"]
pub type NT_Bool = ::std::os::raw::c_int;
pub type NT_Handle = ::std::os::raw::c_uint;
pub type NT_ConnectionDataLogger = NT_Handle;
pub type NT_DataLogger = NT_Handle;
pub type NT_Entry = NT_Handle;
pub type NT_Inst = NT_Handle;
pub type NT_Listener = NT_Handle;
pub type NT_ListenerPoller = NT_Handle;
pub type NT_MultiSubscriber = NT_Handle;
pub type NT_Topic = NT_Handle;
pub type NT_Subscriber = NT_Handle;
pub type NT_Publisher = NT_Handle;
#[repr(u32)]
#[doc = " NetworkTables data types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NT_Type {
    NT_UNASSIGNED = 0,
    NT_BOOLEAN = 1,
    NT_DOUBLE = 2,
    NT_STRING = 4,
    NT_RAW = 8,
    NT_BOOLEAN_ARRAY = 16,
    NT_DOUBLE_ARRAY = 32,
    NT_STRING_ARRAY = 64,
    NT_RPC = 128,
    NT_INTEGER = 256,
    NT_FLOAT = 512,
    NT_INTEGER_ARRAY = 1024,
    NT_FLOAT_ARRAY = 2048,
}
#[repr(u32)]
#[doc = " NetworkTables entry flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NT_EntryFlags {
    NT_PERSISTENT = 1,
    NT_RETAINED = 2,
    NT_UNCACHED = 4,
}
#[repr(u32)]
#[doc = " NetworkTables logging levels."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NT_LogLevel {
    NT_LOG_CRITICAL = 50,
    NT_LOG_ERROR = 40,
    NT_LOG_WARNING = 30,
    NT_LOG_INFO = 20,
    NT_LOG_DEBUG = 10,
    NT_LOG_DEBUG1 = 9,
    NT_LOG_DEBUG2 = 8,
    NT_LOG_DEBUG3 = 7,
    NT_LOG_DEBUG4 = 6,
}
#[repr(u32)]
#[doc = " Client/server modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NT_NetworkMode {
    NT_NET_MODE_NONE = 0,
    NT_NET_MODE_SERVER = 1,
    NT_NET_MODE_CLIENT3 = 2,
    NT_NET_MODE_CLIENT4 = 4,
    NT_NET_MODE_STARTING = 8,
    NT_NET_MODE_LOCAL = 16,
}
#[repr(u32)]
#[doc = " Event notification flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NT_EventFlags {
    NT_EVENT_NONE = 0,
    #[doc = " Initial listener addition."]
    NT_EVENT_IMMEDIATE = 1,
    #[doc = " Client connected (on server, any client connected)."]
    NT_EVENT_CONNECTED = 2,
    #[doc = " Client disconnected (on server, any client disconnected)."]
    NT_EVENT_DISCONNECTED = 4,
    #[doc = " Any connection event (connect or disconnect)."]
    NT_EVENT_CONNECTION = 6,
    #[doc = " New topic published."]
    NT_EVENT_PUBLISH = 8,
    #[doc = " Topic unpublished."]
    NT_EVENT_UNPUBLISH = 16,
    #[doc = " Topic properties changed."]
    NT_EVENT_PROPERTIES = 32,
    #[doc = " Any topic event (publish, unpublish, or properties changed)."]
    NT_EVENT_TOPIC = 56,
    #[doc = " Topic value updated (via network)."]
    NT_EVENT_VALUE_REMOTE = 64,
    #[doc = " Topic value updated (local)."]
    NT_EVENT_VALUE_LOCAL = 128,
    #[doc = " Topic value updated (network or local)."]
    NT_EVENT_VALUE_ALL = 192,
    #[doc = " Log message."]
    NT_EVENT_LOGMESSAGE = 256,
    #[doc = " Time synchronized with server."]
    NT_EVENT_TIMESYNC = 512,
}
#[doc = " NetworkTables Entry Value.  Note this is a typed union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_Value {
    pub type_: NT_Type,
    pub last_change: i64,
    pub server_time: i64,
    pub data: NT_Value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NT_Value__bindgen_ty_1 {
    pub v_boolean: NT_Bool,
    pub v_int: i64,
    pub v_float: f32,
    pub v_double: f64,
    pub v_string: WPI_String,
    pub v_raw: NT_Value__bindgen_ty_1__bindgen_ty_1,
    pub arr_boolean: NT_Value__bindgen_ty_1__bindgen_ty_2,
    pub arr_double: NT_Value__bindgen_ty_1__bindgen_ty_3,
    pub arr_float: NT_Value__bindgen_ty_1__bindgen_ty_4,
    pub arr_int: NT_Value__bindgen_ty_1__bindgen_ty_5,
    pub arr_string: NT_Value__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_1 {
    pub data: *mut u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
impl Default for NT_Value__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_2 {
    pub arr: *mut NT_Bool,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
impl Default for NT_Value__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_3 {
    pub arr: *mut f64,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(size)
        )
    );
}
impl Default for NT_Value__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_4 {
    pub arr: *mut f32,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(size)
        )
    );
}
impl Default for NT_Value__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_5 {
    pub arr: *mut i64,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(size)
        )
    );
}
impl Default for NT_Value__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_6 {
    pub arr: *mut WPI_String,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(size)
        )
    );
}
impl Default for NT_Value__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(NT_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_string)
        )
    );
}
impl Default for NT_Value__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NT_Value() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value>(),
        40usize,
        concat!("Size of: ", stringify!(NT_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_change) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(last_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(server_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(data)
        )
    );
}
impl Default for NT_Value {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " NetworkTables Topic Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TopicInfo {
    #[doc = " Topic handle"]
    pub topic: NT_Topic,
    #[doc = " Topic name"]
    pub name: WPI_String,
    #[doc = " Topic type"]
    pub type_: NT_Type,
    #[doc = " Topic type string"]
    pub type_str: WPI_String,
    #[doc = " Topic properties JSON string"]
    pub properties: WPI_String,
}
#[test]
fn bindgen_test_layout_NT_TopicInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TopicInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TopicInfo>(),
        64usize,
        concat!("Size of: ", stringify!(NT_TopicInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TopicInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TopicInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_str) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(type_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(properties)
        )
    );
}
impl Default for NT_TopicInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " NetworkTables Connection Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_ConnectionInfo {
    #[doc = " The remote identifier (as set on the remote node by NT_StartClient4()."]
    pub remote_id: WPI_String,
    #[doc = " The IP address of the remote node."]
    pub remote_ip: WPI_String,
    #[doc = " The port number of the remote node."]
    pub remote_port: ::std::os::raw::c_uint,
    #[doc = " The last time any update was received from the remote node (same scale as\n returned by nt::Now())."]
    pub last_update: u64,
    #[doc = " The protocol version being used for this connection.  This in protocol\n layer format, so 0x0200 = 2.0, 0x0300 = 3.0)."]
    pub protocol_version: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NT_ConnectionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NT_ConnectionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_ConnectionInfo>(),
        56usize,
        concat!("Size of: ", stringify!(NT_ConnectionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_ConnectionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_ConnectionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_update) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(last_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_version) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(protocol_version)
        )
    );
}
impl Default for NT_ConnectionInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " NetworkTables value event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_ValueEventData {
    #[doc = " Topic handle."]
    pub topic: NT_Topic,
    #[doc = " Subscriber/entry handle."]
    pub subentry: NT_Handle,
    #[doc = " The new value."]
    pub value: NT_Value,
}
#[test]
fn bindgen_test_layout_NT_ValueEventData() {
    const UNINIT: ::std::mem::MaybeUninit<NT_ValueEventData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_ValueEventData>(),
        48usize,
        concat!("Size of: ", stringify!(NT_ValueEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_ValueEventData>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_ValueEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subentry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(subentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(value)
        )
    );
}
impl Default for NT_ValueEventData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " NetworkTables log message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_LogMessage {
    #[doc = " Log level of the message.  See NT_LogLevel."]
    pub level: ::std::os::raw::c_uint,
    #[doc = " The filename of the source file that generated the message."]
    pub filename: WPI_String,
    #[doc = " The line number in the source file that generated the message."]
    pub line: ::std::os::raw::c_uint,
    #[doc = " The message."]
    pub message: WPI_String,
}
#[test]
fn bindgen_test_layout_NT_LogMessage() {
    const UNINIT: ::std::mem::MaybeUninit<NT_LogMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_LogMessage>(),
        48usize,
        concat!("Size of: ", stringify!(NT_LogMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_LogMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_LogMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(message)
        )
    );
}
impl Default for NT_LogMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " NetworkTables time sync event data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NT_TimeSyncEventData {
    #[doc = " Offset between local time and server time, in microseconds. Add this value\n to local time to get the estimated equivalent server time."]
    pub serverTimeOffset: i64,
    #[doc = " Measured round trip time divided by 2, in microseconds."]
    pub rtt2: i64,
    #[doc = " If serverTimeOffset and RTT are valid. An event with this set to false is\n sent when the client disconnects."]
    pub valid: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_TimeSyncEventData() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimeSyncEventData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimeSyncEventData>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimeSyncEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimeSyncEventData>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimeSyncEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTimeOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(serverTimeOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtt2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(rtt2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(valid)
        )
    );
}
#[doc = " NetworkTables event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_Event {
    #[doc = " Listener that triggered this event."]
    pub listener: NT_Handle,
    #[doc = " Event flags (NT_EventFlags). Also indicates the data included with the\n event:\n - NT_EVENT_CONNECTED or NT_EVENT_DISCONNECTED: connInfo\n - NT_EVENT_PUBLISH, NT_EVENT_UNPUBLISH, or NT_EVENT_PROPERTIES: topicInfo\n - NT_EVENT_VALUE_REMOTE, NT_NOTIFY_VALUE_LOCAL: valueData\n - NT_EVENT_LOGMESSAGE: logMessage\n - NT_EVENT_TIMESYNC: timeSyncData"]
    pub flags: ::std::os::raw::c_uint,
    pub data: NT_Event__bindgen_ty_1,
}
#[doc = " Event data; content depends on flags."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NT_Event__bindgen_ty_1 {
    pub connInfo: NT_ConnectionInfo,
    pub topicInfo: NT_TopicInfo,
    pub valueData: NT_ValueEventData,
    pub logMessage: NT_LogMessage,
    pub timeSyncData: NT_TimeSyncEventData,
}
#[test]
fn bindgen_test_layout_NT_Event__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Event__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Event__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(NT_Event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(connInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(topicInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(valueData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logMessage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(logMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeSyncData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(timeSyncData)
        )
    );
}
impl Default for NT_Event__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NT_Event() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Event>(),
        72usize,
        concat!("Size of: ", stringify!(NT_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listener) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(listener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(data)
        )
    );
}
impl Default for NT_Event {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " NetworkTables publish/subscribe options."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NT_PubSubOptions {
    #[doc = " Structure size. Must be set to sizeof(NT_PubSubOptions)."]
    pub structSize: ::std::os::raw::c_uint,
    #[doc = " Polling storage size for a subscription. Specifies the maximum number of\n updates NetworkTables should store between calls to the subscriber's\n ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if\n sendAll is true."]
    pub pollStorage: ::std::os::raw::c_uint,
    #[doc = " How frequently changes will be sent over the network, in seconds.\n NetworkTables may send more frequently than this (e.g. use a combined\n minimum period for all values) or apply a restricted range to this value.\n The default is 100 ms."]
    pub periodic: f64,
    #[doc = " For subscriptions, if non-zero, value updates for ReadQueue() are not\n queued for this publisher."]
    pub excludePublisher: NT_Publisher,
    #[doc = " Send all value changes over the network."]
    pub sendAll: NT_Bool,
    #[doc = " For subscriptions, don't ask for value changes (only topic announcements)."]
    pub topicsOnly: NT_Bool,
    #[doc = " Perform prefix match on subscriber topic names. Is ignored/overridden by\n Subscribe() functions; only present in struct for the purposes of getting\n information about subscriptions."]
    pub prefixMatch: NT_Bool,
    #[doc = " Preserve duplicate value changes (rather than ignoring them)."]
    pub keepDuplicates: NT_Bool,
    #[doc = " For subscriptions, if remote value updates should not be queued for\n ReadQueue(). See also disableLocal."]
    pub disableRemote: NT_Bool,
    #[doc = " For subscriptions, if local value updates should not be queued for\n ReadQueue(). See also disableRemote."]
    pub disableLocal: NT_Bool,
    #[doc = " For entries, don't queue (for ReadQueue) value updates for the entry's\n internal publisher."]
    pub excludeSelf: NT_Bool,
    #[doc = " For subscriptions, don't share the existence of the subscription with the\n network. Note this means updates will not be received from the network\n unless another subscription overlaps with this one, and the subscription\n will not appear in metatopics."]
    pub hidden: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_PubSubOptions() {
    const UNINIT: ::std::mem::MaybeUninit<NT_PubSubOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_PubSubOptions>(),
        56usize,
        concat!("Size of: ", stringify!(NT_PubSubOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_PubSubOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_PubSubOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollStorage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(pollStorage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludePublisher) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(excludePublisher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendAll) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(sendAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsOnly) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(topicsOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixMatch) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(prefixMatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepDuplicates) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(keepDuplicates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableRemote) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(disableRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableLocal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(disableLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludeSelf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(excludeSelf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hidden) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(hidden)
        )
    );
}
extern "C" {
    #[doc = " Get default instance.\n This is the instance used by non-handle-taking functions.\n\n @return Instance handle"]
    pub fn NT_GetDefaultInstance() -> NT_Inst;
}
extern "C" {
    #[doc = " Create an instance.\n\n @return Instance handle"]
    pub fn NT_CreateInstance() -> NT_Inst;
}
extern "C" {
    #[doc = " Destroy an instance.\n The default instance cannot be destroyed.\n\n @param inst Instance handle"]
    pub fn NT_DestroyInstance(inst: NT_Inst);
}
extern "C" {
    #[doc = " Get instance handle from another handle.\n\n @param handle    handle\n @return Instance handle"]
    pub fn NT_GetInstanceFromHandle(handle: NT_Handle) -> NT_Inst;
}
extern "C" {
    #[doc = " Get Entry Handle.\n\n @param inst      instance handle\n @param name      entry name (UTF-8 string)\n @return entry handle"]
    pub fn NT_GetEntry(inst: NT_Inst, name: *const WPI_String) -> NT_Entry;
}
extern "C" {
    #[doc = " Gets the name of the specified entry.\n Returns an empty string if the handle is invalid.\n\n @param entry     entry handle\n @param name      entry name (output parameter)"]
    pub fn NT_GetEntryName(entry: NT_Entry, name: *mut WPI_String);
}
extern "C" {
    #[doc = " Gets the type for the specified key, or unassigned if non existent.\n\n @param entry   entry handle\n @return Entry type"]
    pub fn NT_GetEntryType(entry: NT_Entry) -> NT_Type;
}
extern "C" {
    #[doc = " Gets the last time the entry was changed.\n Returns 0 if the handle is invalid.\n\n @param entry   entry handle\n @return Entry last change time"]
    pub fn NT_GetEntryLastChange(entry: NT_Entry) -> u64;
}
extern "C" {
    #[doc = " Get Entry Value.\n\n Returns copy of current entry value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param value     storage for returned entry value\n\n It is the caller's responsibility to free value once it's no longer\n needed (the utility function NT_DisposeValue() is useful for this\n purpose)."]
    pub fn NT_GetEntryValue(entry: NT_Entry, value: *mut NT_Value);
}
extern "C" {
    #[doc = " Get Entry Value.\n\n Returns copy of current entry value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param types     bitmask of NT_Type values; 0 is treated specially\n                  as a \"don't care\"\n @param value     storage for returned entry value\n\n It is the caller's responsibility to free value once it's no longer\n needed (the utility function NT_DisposeValue() is useful for this\n purpose)."]
    pub fn NT_GetEntryValueType(
        entry: NT_Entry,
        types: ::std::os::raw::c_uint,
        value: *mut NT_Value,
    );
}
extern "C" {
    #[doc = " Set Default Entry Value.\n\n Returns copy of current entry value if it exists.\n Otherwise, sets passed in value, and returns set value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param default_value     value to be set if name does not exist\n @return 0 on error (value not set), 1 on success"]
    pub fn NT_SetDefaultEntryValue(entry: NT_Entry, default_value: *const NT_Value) -> NT_Bool;
}
extern "C" {
    #[doc = " Set Entry Value.\n\n Sets new entry value.  If type of new value differs from the type of the\n currently stored entry, returns error and does not update value.\n\n @param entry     entry handle\n @param value     new entry value\n @return 0 on error (type mismatch), 1 on success"]
    pub fn NT_SetEntryValue(entry: NT_Entry, value: *const NT_Value) -> NT_Bool;
}
extern "C" {
    #[doc = " Set Entry Flags.\n\n @param entry     entry handle\n @param flags     flags value (bitmask of NT_EntryFlags)"]
    pub fn NT_SetEntryFlags(entry: NT_Entry, flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Get Entry Flags.\n\n @param entry     entry handle\n @return Flags value (bitmask of NT_EntryFlags)"]
    pub fn NT_GetEntryFlags(entry: NT_Entry) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Read Entry Queue.\n\n Returns new entry values since last call. The returned array must be freed\n using NT_DisposeValueArray().\n\n @param subentry     subscriber or entry handle\n @param count        count of items in returned array (output)\n @return entry value array; returns NULL and count=0 if no new values"]
    pub fn NT_ReadQueueValue(subentry: NT_Handle, count: *mut usize) -> *mut NT_Value;
}
extern "C" {
    #[doc = " Read Entry Queue.\n\n Returns new entry values since last call. The returned array must be freed\n using NT_DisposeValueArray().\n\n @param subentry     subscriber or entry handle\n @param types        bitmask of NT_Type values; 0 is treated specially\n                     as a \"don't care\"\n @param count        count of items in returned array (output)\n @return entry value array; returns NULL and count=0 if no new values"]
    pub fn NT_ReadQueueValueType(
        subentry: NT_Handle,
        types: ::std::os::raw::c_uint,
        count: *mut usize,
    ) -> *mut NT_Value;
}
extern "C" {
    #[doc = " Get Published Topic Handles.\n\n Returns an array of topic handles.  The results are optionally\n filtered by string prefix and type to only return a subset of all\n topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param types         bitmask of NT_Type values; 0 is treated specially\n                      as a \"don't care\"\n @param count         output parameter; set to length of returned array\n @return Array of topic handles."]
    pub fn NT_GetTopics(
        inst: NT_Inst,
        prefix: *const WPI_String,
        types: ::std::os::raw::c_uint,
        count: *mut usize,
    ) -> *mut NT_Topic;
}
extern "C" {
    #[doc = " Get Published Topic Handles.\n\n Returns an array of topic handles.  The results are optionally\n filtered by string prefix and type to only return a subset of all\n topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param types         array of type strings\n @param types_len     number of elements in types array\n @param count         output parameter; set to length of returned array\n @return Array of topic handles."]
    pub fn NT_GetTopicsStr(
        inst: NT_Inst,
        prefix: *const WPI_String,
        types: *const WPI_String,
        types_len: usize,
        count: *mut usize,
    ) -> *mut NT_Topic;
}
extern "C" {
    #[doc = " Get Topics.\n\n Returns an array of topic information (handle, name, type).  The results are\n optionally filtered by string prefix and type to only return a subset\n of all topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param types         bitmask of NT_Type values; 0 is treated specially\n                      as a \"don't care\"\n @param count         output parameter; set to length of returned array\n @return Array of topic information."]
    pub fn NT_GetTopicInfos(
        inst: NT_Inst,
        prefix: *const WPI_String,
        types: ::std::os::raw::c_uint,
        count: *mut usize,
    ) -> *mut NT_TopicInfo;
}
extern "C" {
    #[doc = " Get Topics.\n\n Returns an array of topic information (handle, name, type).  The results are\n optionally filtered by string prefix and type to only return a subset\n of all topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param types         array of type strings\n @param types_len     number of elements in types array\n @param count         output parameter; set to length of returned array\n @return Array of topic information."]
    pub fn NT_GetTopicInfosStr(
        inst: NT_Inst,
        prefix: *const WPI_String,
        types: *const WPI_String,
        types_len: usize,
        count: *mut usize,
    ) -> *mut NT_TopicInfo;
}
extern "C" {
    #[doc = " Gets Topic Information.\n\n Returns information about a topic (name and type).\n\n @param topic         handle\n @param info          information (output)\n @return True if successful, false on error."]
    pub fn NT_GetTopicInfo(topic: NT_Topic, info: *mut NT_TopicInfo) -> NT_Bool;
}
extern "C" {
    #[doc = " Gets Topic Handle.\n\n Returns topic handle.\n\n @param inst      instance handle\n @param name      topic name\n @return Topic handle."]
    pub fn NT_GetTopic(inst: NT_Inst, name: *const WPI_String) -> NT_Topic;
}
extern "C" {
    #[doc = " Gets the name of the specified topic.\n\n @param topic     topic handle\n @param name  topic name (output); return length of 0 and nullptr if\n handle is invalid."]
    pub fn NT_GetTopicName(topic: NT_Topic, name: *mut WPI_String);
}
extern "C" {
    #[doc = " Gets the type for the specified topic, or unassigned if non existent.\n\n @param topic   topic handle\n @return Topic type"]
    pub fn NT_GetTopicType(topic: NT_Topic) -> NT_Type;
}
extern "C" {
    #[doc = " Gets the type string for the specified topic.  This may have more information\n than the numeric type (especially for raw values).\n\n @param topic topic handle\n @param type  topic type string (output)"]
    pub fn NT_GetTopicTypeString(topic: NT_Topic, type_: *mut WPI_String);
}
extern "C" {
    #[doc = " Sets the persistent property of a topic.  If true, the stored value is\n persistent through server restarts.\n\n @param topic topic handle\n @param value True for persistent, false for not persistent."]
    pub fn NT_SetTopicPersistent(topic: NT_Topic, value: NT_Bool);
}
extern "C" {
    #[doc = " Gets the persistent property of a topic.\n\n @param topic topic handle\n @return persistent property value"]
    pub fn NT_GetTopicPersistent(topic: NT_Topic) -> NT_Bool;
}
extern "C" {
    #[doc = " Sets the retained property of a topic.  If true, the server retains the\n topic even when there are no publishers.\n\n @param topic topic handle\n @param value new retained property value"]
    pub fn NT_SetTopicRetained(topic: NT_Topic, value: NT_Bool);
}
extern "C" {
    #[doc = " Gets the retained property of a topic.\n\n @param topic topic handle\n @return retained property value"]
    pub fn NT_GetTopicRetained(topic: NT_Topic) -> NT_Bool;
}
extern "C" {
    #[doc = " Sets the cached property of a topic.  If true, the server and clients will\n store the latest value, allowing the value to be read (and not just accessed\n through event queues and listeners).\n\n @param topic topic handle\n @param value True for cached, false for not cached"]
    pub fn NT_SetTopicCached(topic: NT_Topic, value: NT_Bool);
}
extern "C" {
    #[doc = " Gets the cached property of a topic.\n\n @param topic topic handle\n @return cached property value"]
    pub fn NT_GetTopicCached(topic: NT_Topic) -> NT_Bool;
}
extern "C" {
    #[doc = " Determine if topic exists (e.g. has at least one publisher).\n\n @param handle Topic, entry, or subscriber handle.\n @return True if topic exists."]
    pub fn NT_GetTopicExists(handle: NT_Handle) -> NT_Bool;
}
extern "C" {
    #[doc = " Gets the current value of a property (as a JSON string).\n\n @param topic topic handle\n @param name property name\n @param property JSON string (output)"]
    pub fn NT_GetTopicProperty(topic: NT_Topic, name: *const WPI_String, property: *mut WPI_String);
}
extern "C" {
    #[doc = " Sets a property value.\n\n @param topic topic handle\n @param name property name\n @param value property value (JSON string)"]
    pub fn NT_SetTopicProperty(
        topic: NT_Topic,
        name: *const WPI_String,
        value: *const WPI_String,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Deletes a property.  Has no effect if the property does not exist.\n\n @param topic topic handle\n @param name property name"]
    pub fn NT_DeleteTopicProperty(topic: NT_Topic, name: *const WPI_String);
}
extern "C" {
    #[doc = " Gets all topic properties as a JSON string.  Each key in the object\n is the property name, and the corresponding value is the property value.\n\n @param topic topic handle\n @param properties JSON string (output)"]
    pub fn NT_GetTopicProperties(topic: NT_Topic, properties: *mut WPI_String);
}
extern "C" {
    #[doc = " Updates multiple topic properties.  Each key in the passed-in JSON object is\n the name of the property to add/update, and the corresponding value is the\n property value to set for that property.  Null values result in deletion\n of the corresponding property.\n\n @param topic topic handle\n @param properties JSON object string with keys to add/update/delete\n @return False if properties are not a valid JSON object"]
    pub fn NT_SetTopicProperties(topic: NT_Topic, properties: *const WPI_String) -> NT_Bool;
}
extern "C" {
    #[doc = " Creates a new subscriber to value changes on a topic.\n\n @param topic topic handle\n @param type expected type\n @param typeStr expected type string\n @param options subscription options\n @return Subscriber handle"]
    pub fn NT_Subscribe(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const WPI_String,
        options: *const NT_PubSubOptions,
    ) -> NT_Subscriber;
}
extern "C" {
    #[doc = " Stops subscriber.\n\n @param sub subscriber handle"]
    pub fn NT_Unsubscribe(sub: NT_Subscriber);
}
extern "C" {
    #[doc = " Creates a new publisher to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param options publish options\n @return Publisher handle"]
    pub fn NT_Publish(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const WPI_String,
        options: *const NT_PubSubOptions,
    ) -> NT_Publisher;
}
extern "C" {
    #[doc = " Creates a new publisher to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param properties initial properties (JSON object)\n @param options publish options\n @return Publisher handle"]
    pub fn NT_PublishEx(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const WPI_String,
        properties: *const WPI_String,
        options: *const NT_PubSubOptions,
    ) -> NT_Publisher;
}
extern "C" {
    #[doc = " Stops publisher.\n\n @param pubentry publisher/entry handle"]
    pub fn NT_Unpublish(pubentry: NT_Handle);
}
extern "C" {
    #[doc = " @brief Creates a new entry (subscriber and weak publisher) to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param options publish options\n @return Entry handle"]
    pub fn NT_GetEntryEx(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const WPI_String,
        options: *const NT_PubSubOptions,
    ) -> NT_Entry;
}
extern "C" {
    #[doc = " Stops entry subscriber/publisher.\n\n @param entry entry handle"]
    pub fn NT_ReleaseEntry(entry: NT_Entry);
}
extern "C" {
    #[doc = " Stops entry/subscriber/publisher.\n\n @param pubsubentry entry/subscriber/publisher handle"]
    pub fn NT_Release(pubsubentry: NT_Handle);
}
extern "C" {
    #[doc = " Gets the topic handle from an entry/subscriber/publisher handle.\n\n @param pubsubentry entry/subscriber/publisher handle\n @return Topic handle"]
    pub fn NT_GetTopicFromHandle(pubsubentry: NT_Handle) -> NT_Topic;
}
extern "C" {
    #[doc = " Subscribes to multiple topics based on one or more topic name prefixes. Can\n be used in combination with a Value Listener or ReadQueueValue() to get value\n changes across all matching topics.\n\n @param inst instance handle\n @param prefixes topic name prefixes\n @param prefixes_len number of elements in prefixes array\n @param options subscriber options\n @return subscriber handle"]
    pub fn NT_SubscribeMultiple(
        inst: NT_Inst,
        prefixes: *const WPI_String,
        prefixes_len: usize,
        options: *const NT_PubSubOptions,
    ) -> NT_MultiSubscriber;
}
extern "C" {
    #[doc = " Unsubscribes a multi-subscriber.\n\n @param sub multi-subscriber handle"]
    pub fn NT_UnsubscribeMultiple(sub: NT_MultiSubscriber);
}
#[doc = " Event listener callback function.\n\n @param data            data pointer provided to callback creation function\n @param event           event info"]
pub type NT_ListenerCallback = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const NT_Event),
>;
extern "C" {
    #[doc = " Creates a listener poller.\n\n A poller provides a single queue of poll events.  Events linked to this\n poller (using NT_AddPolledXListener()) will be stored in the queue and\n must be collected by calling NT_ReadListenerQueue().\n The returned handle must be destroyed with NT_DestroyListenerPoller().\n\n @param inst      instance handle\n @return poller handle"]
    pub fn NT_CreateListenerPoller(inst: NT_Inst) -> NT_ListenerPoller;
}
extern "C" {
    #[doc = " Destroys a listener poller.  This will abort any blocked polling\n call and prevent additional events from being generated for this poller.\n\n @param poller    poller handle"]
    pub fn NT_DestroyListenerPoller(poller: NT_ListenerPoller);
}
extern "C" {
    #[doc = " Read notifications.\n\n @param poller    poller handle\n @param len       length of returned array (output)\n @return Array of events.  Returns NULL and len=0 if no events since last\n         call."]
    pub fn NT_ReadListenerQueue(poller: NT_ListenerPoller, len: *mut usize) -> *mut NT_Event;
}
extern "C" {
    #[doc = " Removes a listener.\n\n @param listener Listener handle to remove"]
    pub fn NT_RemoveListener(listener: NT_Listener);
}
extern "C" {
    #[doc = " Wait for the listener queue to be empty. This is primarily useful\n for deterministic testing. This blocks until either the listener\n queue is empty (e.g. there are no more events that need to be passed along to\n callbacks or poll queues) or the timeout expires.\n\n @param handle  handle\n @param timeout timeout, in seconds. Set to 0 for non-blocking behavior, or a\n                negative value to block indefinitely\n @return False if timed out, otherwise true."]
    pub fn NT_WaitForListenerQueue(handle: NT_Handle, timeout: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Create a listener for changes to topics with names that start with\n the given prefix. This creates a corresponding internal subscriber with the\n lifetime of the listener.\n\n @param inst Instance handle\n @param prefix Topic name string prefix\n @param mask Bitmask of NT_EventFlags values (only topic and value events will\n             be generated)\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListenerSingle(
        inst: NT_Inst,
        prefix: *const WPI_String,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Create a listener for changes to topics with names that start with any of\n the given prefixes. This creates a corresponding internal subscriber with the\n lifetime of the listener.\n\n @param inst Instance handle\n @param prefixes Topic name string prefixes\n @param prefixes_len Number of elements in prefixes array\n @param mask Bitmask of NT_EventFlags values (only topic and value events will\n             be generated)\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListenerMultiple(
        inst: NT_Inst,
        prefixes: *const WPI_String,
        prefixes_len: usize,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Create a listener.\n\n Some combinations of handle and mask have no effect:\n - connection and log message events are only generated on instances\n - topic and value events are only generated on non-instances\n\n Adding value and topic events on a topic will create a corresponding internal\n subscriber with the lifetime of the listener.\n\n Adding a log message listener through this function will only result in\n events at NT_LOG_INFO or higher; for more customized settings, use\n NT_AddLogger().\n\n @param handle Handle\n @param mask Bitmask of NT_EventFlags values\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListener(
        handle: NT_Handle,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled topic listener. This creates a corresponding internal\n subscriber with the lifetime of the listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n @param poller            poller handle\n @param prefix            UTF-8 string prefix\n @param mask              NT_EventFlags bitmask (only topic and value events\n will be generated)\n @return Listener handle"]
    pub fn NT_AddPolledListenerSingle(
        poller: NT_ListenerPoller,
        prefix: *const WPI_String,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled topic listener. This creates a corresponding internal\n subscriber with the lifetime of the listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n @param poller            poller handle\n @param prefixes          array of UTF-8 string prefixes\n @param prefixes_len      Length of prefixes array\n @param mask              NT_EventFlags bitmask (only topic and value events\n will be generated)\n @return Listener handle"]
    pub fn NT_AddPolledListenerMultiple(
        poller: NT_ListenerPoller,
        prefixes: *const WPI_String,
        prefixes_len: usize,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n Some combinations of handle and mask have no effect:\n - connection and log message events are only generated on instances\n - topic and value events are only generated on non-instances\n\n Adding value and topic events on a topic will create a corresponding internal\n subscriber with the lifetime of the listener.\n\n Adding a log message listener through this function will only result in\n events at NT_LOG_INFO or higher; for more customized settings, use\n NT_AddPolledLogger().\n\n @param poller            poller handle\n @param handle            handle\n @param mask              NT_NotifyKind bitmask\n @return Listener handle"]
    pub fn NT_AddPolledListener(
        poller: NT_ListenerPoller,
        handle: NT_Handle,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Get the current network mode.\n\n @param inst  instance handle\n @return Bitmask of NT_NetworkMode."]
    pub fn NT_GetNetworkMode(inst: NT_Inst) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Starts local-only operation.  Prevents calls to NT_StartServer or\n NT_StartClient from taking effect.  Has no effect if NT_StartServer or\n NT_StartClient has already been called."]
    pub fn NT_StartLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Stops local-only operation.  NT_StartServer or NT_StartClient can be called\n after this call to start a server or client."]
    pub fn NT_StopLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts a server using the specified filename, listening address, and port.\n\n @param inst              instance handle\n @param persist_filename  the name of the persist file to use (UTF-8 string,\n                          null terminated)\n @param listen_address    the address to listen on, or null to listen on any\n                          address. (UTF-8 string, null terminated)\n @param port3             port to communicate over (NT3)\n @param port4             port to communicate over (NT4)"]
    pub fn NT_StartServer(
        inst: NT_Inst,
        persist_filename: *const WPI_String,
        listen_address: *const WPI_String,
        port3: ::std::os::raw::c_uint,
        port4: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Stops the server if it is running.\n\n @param inst  instance handle"]
    pub fn NT_StopServer(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts a NT3 client.  Use NT_SetServer or NT_SetServerTeam to set the server\n name and port.\n\n @param inst      instance handle\n @param identity  network identity to advertise (cannot be empty string)"]
    pub fn NT_StartClient3(inst: NT_Inst, identity: *const WPI_String);
}
extern "C" {
    #[doc = " Starts a NT4 client.  Use NT_SetServer or NT_SetServerTeam to set the server\n name and port.\n\n @param inst      instance handle\n @param identity  network identity to advertise (cannot be empty string)"]
    pub fn NT_StartClient4(inst: NT_Inst, identity: *const WPI_String);
}
extern "C" {
    #[doc = " Stops the client if it is running.\n\n @param inst  instance handle"]
    pub fn NT_StopClient(inst: NT_Inst);
}
extern "C" {
    #[doc = " Sets server address and port for client (without restarting client).\n\n @param inst        instance handle\n @param server_name server name (UTF-8 string, null terminated)\n @param port        port to communicate over"]
    pub fn NT_SetServer(
        inst: NT_Inst,
        server_name: *const WPI_String,
        port: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Sets server addresses for client (without restarting client).\n The client will attempt to connect to each server in round robin fashion.\n\n @param inst         instance handle\n @param count        length of the server_names and ports arrays\n @param server_names array of server names (each a UTF-8 string, null\n                     terminated)\n @param ports        array of ports to communicate over (one for each server)"]
    pub fn NT_SetServerMulti(
        inst: NT_Inst,
        count: usize,
        server_names: *const WPI_String,
        ports: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Sets server addresses and port for client (without restarting client).\n Connects using commonly known robot addresses for the specified team.\n\n @param inst        instance handle\n @param team        team number\n @param port        port to communicate over"]
    pub fn NT_SetServerTeam(
        inst: NT_Inst,
        team: ::std::os::raw::c_uint,
        port: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Disconnects the client if it's running and connected. This will automatically\n start reconnection attempts to the current server list.\n\n @param inst instance handle"]
    pub fn NT_Disconnect(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts requesting server address from Driver Station.\n This connects to the Driver Station running on localhost to obtain the\n server IP address.\n\n @param inst  instance handle\n @param port  server port to use in combination with IP from DS"]
    pub fn NT_StartDSClient(inst: NT_Inst, port: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Stops requesting server address from Driver Station.\n\n @param inst  instance handle"]
    pub fn NT_StopDSClient(inst: NT_Inst);
}
extern "C" {
    #[doc = " Flush local updates.\n\n Forces an immediate flush of all local changes to the client/server.\n This does not flush to the network.\n\n Normally this is done on a regularly scheduled interval.\n\n @param inst      instance handle"]
    pub fn NT_FlushLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Flush to network.\n\n Forces an immediate flush of all local entry changes to network.\n Normally this is done on a regularly scheduled interval (set\n by update rates on individual publishers).\n\n Note: flushes are rate limited to avoid excessive network traffic.  If\n the time between calls is too short, the flush will occur after the minimum\n time elapses (rather than immediately).\n\n @param inst      instance handle"]
    pub fn NT_Flush(inst: NT_Inst);
}
extern "C" {
    #[doc = " Get information on the currently established network connections.\n If operating as a client, this will return either zero or one values.\n\n @param inst  instance handle\n @param count returns the number of elements in the array\n @return      array of connection information\n\n It is the caller's responsibility to free the array. The\n NT_DisposeConnectionInfoArray function is useful for this purpose."]
    pub fn NT_GetConnections(inst: NT_Inst, count: *mut usize) -> *mut NT_ConnectionInfo;
}
extern "C" {
    #[doc = " Return whether or not the instance is connected to another node.\n\n @param inst  instance handle\n @return True if connected."]
    pub fn NT_IsConnected(inst: NT_Inst) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the time offset between server time and local time. Add this value to\n local time to get the estimated equivalent server time. In server mode, this\n always returns a valid value of 0. In client mode, this returns the time\n offset only if the client and server are connected and have exchanged\n synchronization messages. Note the time offset may change over time as it is\n periodically updated; to receive updates as events, add a listener to the\n \"time sync\" event.\n\n @param inst instance handle\n @param valid set to true if the return value is valid, false otherwise\n              (output)\n @return Time offset in microseconds (if valid is set to true)"]
    pub fn NT_GetServerTimeOffset(inst: NT_Inst, valid: *mut NT_Bool) -> i64;
}
extern "C" {
    #[doc = " Frees value memory.\n\n @param value   value to free"]
    pub fn NT_DisposeValue(value: *mut NT_Value);
}
extern "C" {
    #[doc = " Initializes a NT_Value.\n Sets type to NT_UNASSIGNED and clears rest of struct.\n\n @param value value to initialize"]
    pub fn NT_InitValue(value: *mut NT_Value);
}
extern "C" {
    #[doc = " Frees an array of NT_Values.\n\n @param arr   pointer to the value array to free\n @param count number of elements in the array\n\n Note that the individual NT_Values in the array should NOT be\n freed before calling this. This function will free all the values\n individually."]
    pub fn NT_DisposeValueArray(arr: *mut NT_Value, count: usize);
}
extern "C" {
    #[doc = " Disposes a connection info array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeConnectionInfoArray(arr: *mut NT_ConnectionInfo, count: usize);
}
extern "C" {
    #[doc = " Disposes a topic info array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeTopicInfoArray(arr: *mut NT_TopicInfo, count: usize);
}
extern "C" {
    #[doc = " Disposes a single topic info (as returned by NT_GetTopicInfo).\n\n @param info  pointer to the info to dispose"]
    pub fn NT_DisposeTopicInfo(info: *mut NT_TopicInfo);
}
extern "C" {
    #[doc = " Disposes an event array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeEventArray(arr: *mut NT_Event, count: usize);
}
extern "C" {
    #[doc = " Disposes a single event.\n\n @param event  pointer to the event to dispose"]
    pub fn NT_DisposeEvent(event: *mut NT_Event);
}
extern "C" {
    #[doc = " Returns monotonic current time in 1 us increments.\n This is the same time base used for entry and connection timestamps.\n This function by default simply wraps WPI_Now(), but if NT_SetNow() is\n called, this function instead returns the value passed to NT_SetNow();\n this can be used to reduce overhead.\n\n @return Timestamp"]
    pub fn NT_Now() -> i64;
}
extern "C" {
    #[doc = " Sets the current timestamp used for timestamping values that do not\n provide a timestamp (e.g. a value of 0 is passed).  For consistency,\n it also results in NT_Now() returning the set value.  This should generally\n be used only if the overhead of calling WPI_Now() is a concern.\n If used, it should be called periodically with the value of WPI_Now().\n\n @param timestamp timestamp (1 us increments)"]
    pub fn NT_SetNow(timestamp: i64);
}
extern "C" {
    #[doc = " Starts logging entry changes to a DataLog.\n\n @param inst instance handle\n @param log data log object; lifetime must extend until StopEntryDataLog is\n            called or the instance is destroyed\n @param prefix only store entries with names that start with this prefix;\n               the prefix is not included in the data log entry name\n @param logPrefix prefix to add to data log entry names\n @return Data logger handle"]
    pub fn NT_StartEntryDataLog(
        inst: NT_Inst,
        log: *mut WPI_DataLog,
        prefix: *const WPI_String,
        logPrefix: *const WPI_String,
    ) -> NT_DataLogger;
}
extern "C" {
    #[doc = " Stops logging entry changes to a DataLog.\n\n @param logger data logger handle"]
    pub fn NT_StopEntryDataLog(logger: NT_DataLogger);
}
extern "C" {
    #[doc = " Starts logging connection changes to a DataLog.\n\n @param inst instance handle\n @param log data log object; lifetime must extend until StopConnectionDataLog\n            is called or the instance is destroyed\n @param name data log entry name\n @return Data logger handle"]
    pub fn NT_StartConnectionDataLog(
        inst: NT_Inst,
        log: *mut WPI_DataLog,
        name: *const WPI_String,
    ) -> NT_ConnectionDataLogger;
}
extern "C" {
    #[doc = " Stops logging connection changes to a DataLog.\n\n @param logger data logger handle"]
    pub fn NT_StopConnectionDataLog(logger: NT_ConnectionDataLogger);
}
extern "C" {
    #[doc = " Add logger callback function.  By default, log messages are sent to stderr;\n this function sends log messages to the provided callback function instead.\n The callback function will only be called for log messages with level\n greater than or equal to min_level and less than or equal to max_level;\n messages outside this range will be silently ignored.\n\n @param inst        instance handle\n @param min_level   minimum log level\n @param max_level   maximum log level\n @param data        data pointer to pass to func\n @param func        listener callback function\n @return Listener handle"]
    pub fn NT_AddLogger(
        inst: NT_Inst,
        min_level: ::std::os::raw::c_uint,
        max_level: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        func: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Set the log level for a listener poller.  Events will only be generated for\n log messages with level greater than or equal to min_level and less than or\n equal to max_level; messages outside this range will be silently ignored.\n\n @param poller        poller handle\n @param min_level     minimum log level\n @param max_level     maximum log level\n @return Listener handle"]
    pub fn NT_AddPolledLogger(
        poller: NT_ListenerPoller,
        min_level: ::std::os::raw::c_uint,
        max_level: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Returns whether there is a data schema already registered with the given\n name. This does NOT perform a check as to whether the schema has already\n been published by another node on the network.\n\n @param inst instance\n @param name Name (the string passed as the data type for topics using this\n             schema)\n @return True if schema already registered"]
    pub fn NT_HasSchema(inst: NT_Inst, name: *const WPI_String) -> NT_Bool;
}
extern "C" {
    #[doc = " Registers a data schema.  Data schemas provide information for how a\n certain data type string can be decoded.  The type string of a data schema\n indicates the type of the schema itself (e.g. \"protobuf\" for protobuf\n schemas, \"struct\" for struct schemas, etc). In NetworkTables, schemas are\n published just like normal topics, with the name being generated from the\n provided name: \"/.schema/<name>\".  Duplicate calls to this function with\n the same name are silently ignored.\n\n @param inst instance\n @param name Name (the string passed as the data type for topics using this\n             schema)\n @param type Type of schema (e.g. \"protobuf\", \"struct\", etc)\n @param schema Schema data\n @param schemaSize Size of schema data"]
    pub fn NT_AddSchema(
        inst: NT_Inst,
        name: *const WPI_String,
        type_: *const WPI_String,
        schema: *const u8,
        schemaSize: usize,
    );
}
extern "C" {
    #[doc = " Allocates an array of chars.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated char array\n\n After use, the array should be freed using the NT_FreeCharArray()\n function."]
    pub fn NT_AllocateCharArray(size: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocates an array of booleans.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated boolean array\n\n After use, the array should be freed using the NT_FreeBooleanArray()\n function."]
    pub fn NT_AllocateBooleanArray(size: usize) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Allocates an array of ints.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeIntArray()\n function."]
    pub fn NT_AllocateIntegerArray(size: usize) -> *mut i64;
}
extern "C" {
    #[doc = " Allocates an array of floats.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeFloatArray()\n function."]
    pub fn NT_AllocateFloatArray(size: usize) -> *mut f32;
}
extern "C" {
    #[doc = " Allocates an array of doubles.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeDoubleArray()\n function."]
    pub fn NT_AllocateDoubleArray(size: usize) -> *mut f64;
}
extern "C" {
    #[doc = " Frees an array of chars.\n\n @param v_char pointer to the char array to free"]
    pub fn NT_FreeCharArray(v_char: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Frees an array of booleans.\n\n @param v_boolean pointer to the boolean array to free"]
    pub fn NT_FreeBooleanArray(v_boolean: *mut NT_Bool);
}
extern "C" {
    #[doc = " Frees an array of ints.\n\n @param v_int pointer to the int array to free"]
    pub fn NT_FreeIntegerArray(v_int: *mut i64);
}
extern "C" {
    #[doc = " Frees an array of floats.\n\n @param v_float pointer to the float array to free"]
    pub fn NT_FreeFloatArray(v_float: *mut f32);
}
extern "C" {
    #[doc = " Frees an array of doubles.\n\n @param v_double pointer to the double array to free"]
    pub fn NT_FreeDoubleArray(v_double: *mut f64);
}
extern "C" {
    #[doc = " Returns the type of an NT_Value struct.\n Note that one of the type options is \"unassigned\".\n\n @param value  The NT_Value struct to get the type from.\n @return       The type of the value, or unassigned if null."]
    pub fn NT_GetValueType(value: *const NT_Value) -> NT_Type;
}
extern "C" {
    #[doc = " Returns the boolean from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the boolean from\n @param last_change returns time in ms since the last change in the value\n @param v_boolean   returns the boolean assigned to the name\n @return            1 if successful, or 0 if value is null or not a boolean"]
    pub fn NT_GetValueBoolean(
        value: *const NT_Value,
        last_change: *mut u64,
        v_boolean: *mut NT_Bool,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the int from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the int from\n @param last_change returns time in ms since the last change in the value\n @param v_int       returns the int assigned to the name\n @return            1 if successful, or 0 if value is null or not an int"]
    pub fn NT_GetValueInteger(
        value: *const NT_Value,
        last_change: *mut u64,
        v_int: *mut i64,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the float from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the float from\n @param last_change returns time in ms since the last change in the value\n @param v_float     returns the float assigned to the name\n @return            1 if successful, or 0 if value is null or not a float"]
    pub fn NT_GetValueFloat(
        value: *const NT_Value,
        last_change: *mut u64,
        v_float: *mut f32,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the double from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the double from\n @param last_change returns time in ms since the last change in the value\n @param v_double    returns the double assigned to the name\n @return            1 if successful, or 0 if value is null or not a double"]
    pub fn NT_GetValueDouble(
        value: *const NT_Value,
        last_change: *mut u64,
        v_double: *mut f64,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns a copy of the string from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the string from\n @param last_change returns time in ms since the last change in the value\n @param str_len     returns the length of the string\n @return            pointer to the string (UTF-8), or null if error\n\n It is the caller's responsibility to free the string once its no longer\n needed. The NT_FreeCharArray() function is useful for this purpose. The\n returned string is a copy of the string in the value, and must be freed\n separately."]
    pub fn NT_GetValueString(
        value: *const NT_Value,
        last_change: *mut u64,
        str_len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a copy of the raw value from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the string from\n @param last_change returns time in ms since the last change in the value\n @param raw_len     returns the length of the string\n @return            pointer to the raw value (UTF-8), or null if error\n\n It is the caller's responsibility to free the raw value once its no longer\n needed. The NT_FreeCharArray() function is useful for this purpose. The\n returned string is a copy of the string in the value, and must be freed\n separately."]
    pub fn NT_GetValueRaw(
        value: *const NT_Value,
        last_change: *mut u64,
        raw_len: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Returns a copy of the boolean array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the boolean array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the boolean array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeBooleanArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueBooleanArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Returns a copy of the int array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the int array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the int array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeIntArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueIntegerArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut i64;
}
extern "C" {
    #[doc = " Returns a copy of the float array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the float array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the float array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeFloatArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueFloatArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " Returns a copy of the double array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the double array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the double array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeDoubleArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueDoubleArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " Returns a copy of the struct WPI_String array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the struct WPI_String array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the struct WPI_String array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The WPI_FreeStringArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately. Note that the individual struct WPI_Strings should not be\n freed, but the entire array should be freed at once. The\n WPI_FreeStringArray() function will free all the struct WPI_Strings."]
    pub fn NT_GetValueStringArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut WPI_String;
}
#[doc = " Subscriber options. Different from PubSubOptions in this reflects only\n options that are sent over the network."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NT_Meta_SubscriberOptions {
    pub periodic: f64,
    pub topicsOnly: NT_Bool,
    pub sendAll: NT_Bool,
    pub prefixMatch: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_Meta_SubscriberOptions() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_SubscriberOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_SubscriberOptions>(),
        24usize,
        concat!("Size of: ", stringify!(NT_Meta_SubscriberOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_SubscriberOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_SubscriberOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsOnly) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(topicsOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendAll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(sendAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixMatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(prefixMatch)
        )
    );
}
#[doc = " Topic publisher (as published via `$pub$<topic>`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_TopicPublisher {
    pub client: WPI_String,
    pub pubuid: u64,
}
#[test]
fn bindgen_test_layout_NT_Meta_TopicPublisher() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_TopicPublisher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_TopicPublisher>(),
        24usize,
        concat!("Size of: ", stringify!(NT_Meta_TopicPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_TopicPublisher>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_TopicPublisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicPublisher),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pubuid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicPublisher),
            "::",
            stringify!(pubuid)
        )
    );
}
impl Default for NT_Meta_TopicPublisher {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Topic subscriber (as published via `$sub$<topic>`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_TopicSubscriber {
    pub client: WPI_String,
    pub subuid: u64,
    pub options: NT_Meta_SubscriberOptions,
}
#[test]
fn bindgen_test_layout_NT_Meta_TopicSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_TopicSubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_TopicSubscriber>(),
        48usize,
        concat!("Size of: ", stringify!(NT_Meta_TopicSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_TopicSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_TopicSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subuid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(subuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(options)
        )
    );
}
impl Default for NT_Meta_TopicSubscriber {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Client publisher (as published via `$clientpub$<client>` or `$serverpub`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_ClientPublisher {
    pub uid: i64,
    pub topic: WPI_String,
}
#[test]
fn bindgen_test_layout_NT_Meta_ClientPublisher() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_ClientPublisher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_ClientPublisher>(),
        24usize,
        concat!("Size of: ", stringify!(NT_Meta_ClientPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_ClientPublisher>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_ClientPublisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientPublisher),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientPublisher),
            "::",
            stringify!(topic)
        )
    );
}
impl Default for NT_Meta_ClientPublisher {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Client subscriber (as published via `$clientsub$<client>` or `$serversub`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_ClientSubscriber {
    pub uid: i64,
    pub topicsCount: usize,
    pub topics: *mut WPI_String,
    pub options: NT_Meta_SubscriberOptions,
}
#[test]
fn bindgen_test_layout_NT_Meta_ClientSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_ClientSubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_ClientSubscriber>(),
        48usize,
        concat!("Size of: ", stringify!(NT_Meta_ClientSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_ClientSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_ClientSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(topicsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topics) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(topics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(options)
        )
    );
}
impl Default for NT_Meta_ClientSubscriber {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Client (as published via `$clients`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_Client {
    pub id: WPI_String,
    pub conn: WPI_String,
    pub version: u16,
}
#[test]
fn bindgen_test_layout_NT_Meta_Client() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_Client> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_Client>(),
        40usize,
        concat!("Size of: ", stringify!(NT_Meta_Client))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_Client>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_Client))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(conn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(version)
        )
    );
}
impl Default for NT_Meta_Client {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Decodes `$pub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of TopicPublishers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeTopicPublishers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_TopicPublisher;
}
extern "C" {
    #[doc = " Decodes `$sub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of TopicSubscribers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeTopicSubscribers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_TopicSubscriber;
}
extern "C" {
    #[doc = " Decodes `$clientpub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of ClientPublishers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClientPublishers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_ClientPublisher;
}
extern "C" {
    #[doc = " Decodes `$clientsub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of ClientSubscribers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClientSubscribers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_ClientSubscriber;
}
extern "C" {
    #[doc = " Decodes `$clients` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of Clients, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClients(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_Client;
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_TopicPublisher.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeTopicPublishers(arr: *mut NT_Meta_TopicPublisher, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_TopicSubscriber.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeTopicSubscribers(arr: *mut NT_Meta_TopicSubscriber, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_ClientPublisher.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClientPublishers(arr: *mut NT_Meta_ClientPublisher, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_ClientSubscriber.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClientSubscribers(arr: *mut NT_Meta_ClientSubscriber, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_Client.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClients(arr: *mut NT_Meta_Client, count: usize);
}
#[doc = " Timestamped Boolean.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NT_TimestampedBoolean {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_TimestampedBoolean() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedBoolean> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedBoolean>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedBoolean))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetBoolean(pubentry: NT_Handle, time: i64, value: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultBoolean(pubentry: NT_Handle, defaultValue: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetBoolean(subentry: NT_Handle, defaultValue: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicBoolean(
        subentry: NT_Handle,
        defaultValue: NT_Bool,
        value: *mut NT_TimestampedBoolean,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicBoolean).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedBoolean(value: *mut NT_TimestampedBoolean);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueBoolean(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedBoolean;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueBoolean).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueBoolean(arr: *mut NT_TimestampedBoolean, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesBoolean(subentry: NT_Handle, len: *mut usize) -> *mut NT_Bool;
}
#[doc = " Timestamped Integer.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NT_TimestampedInteger {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: i64,
}
#[test]
fn bindgen_test_layout_NT_TimestampedInteger() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedInteger> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedInteger>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedInteger))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedInteger>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedInteger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetInteger(pubentry: NT_Handle, time: i64, value: i64) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultInteger(pubentry: NT_Handle, defaultValue: i64) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetInteger(subentry: NT_Handle, defaultValue: i64) -> i64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicInteger(
        subentry: NT_Handle,
        defaultValue: i64,
        value: *mut NT_TimestampedInteger,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicInteger).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedInteger(value: *mut NT_TimestampedInteger);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueInteger(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedInteger;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueInteger).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueInteger(arr: *mut NT_TimestampedInteger, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesInteger(subentry: NT_Handle, len: *mut usize) -> *mut i64;
}
#[doc = " Timestamped Float.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NT_TimestampedFloat {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_NT_TimestampedFloat() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedFloat>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetFloat(pubentry: NT_Handle, time: i64, value: f32) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultFloat(pubentry: NT_Handle, defaultValue: f32) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetFloat(subentry: NT_Handle, defaultValue: f32) -> f32;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicFloat(
        subentry: NT_Handle,
        defaultValue: f32,
        value: *mut NT_TimestampedFloat,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicFloat).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedFloat(value: *mut NT_TimestampedFloat);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueFloat(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedFloat;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueFloat).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueFloat(arr: *mut NT_TimestampedFloat, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesFloat(subentry: NT_Handle, len: *mut usize) -> *mut f32;
}
#[doc = " Timestamped Double.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NT_TimestampedDouble {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: f64,
}
#[test]
fn bindgen_test_layout_NT_TimestampedDouble() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedDouble>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetDouble(pubentry: NT_Handle, time: i64, value: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultDouble(pubentry: NT_Handle, defaultValue: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetDouble(subentry: NT_Handle, defaultValue: f64) -> f64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicDouble(
        subentry: NT_Handle,
        defaultValue: f64,
        value: *mut NT_TimestampedDouble,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicDouble).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedDouble(value: *mut NT_TimestampedDouble);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueDouble(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedDouble;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueDouble).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueDouble(arr: *mut NT_TimestampedDouble, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesDouble(subentry: NT_Handle, len: *mut usize) -> *mut f64;
}
#[doc = " Timestamped String.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedString {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: WPI_String,
}
#[test]
fn bindgen_test_layout_NT_TimestampedString() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedString>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedString))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedString>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(value)
        )
    );
}
impl Default for NT_TimestampedString {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetString(pubentry: NT_Handle, time: i64, value: *const WPI_String) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultString(pubentry: NT_Handle, defaultValue: *const WPI_String) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value returned value (output)\n"]
    pub fn NT_GetString(
        subentry: NT_Handle,
        defaultValue: *const WPI_String,
        value: *mut WPI_String,
    );
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicString(
        subentry: NT_Handle,
        defaultValue: *const WPI_String,
        value: *mut NT_TimestampedString,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicString).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedString(value: *mut NT_TimestampedString);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueString(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedString;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueString).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueString(arr: *mut NT_TimestampedString, len: usize);
}
#[doc = " Timestamped Raw.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedRaw {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut u8,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedRaw() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedRaw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedRaw>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedRaw))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedRaw>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedRaw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(len)
        )
    );
}
impl Default for NT_TimestampedRaw {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetRaw(pubentry: NT_Handle, time: i64, value: *const u8, len: usize) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultRaw(
        pubentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetRaw(
        subentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicRaw(
        subentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
        value: *mut NT_TimestampedRaw,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicRaw).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedRaw(value: *mut NT_TimestampedRaw);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueRaw(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedRaw;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueRaw).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueRaw(arr: *mut NT_TimestampedRaw, len: usize);
}
#[doc = " Timestamped BooleanArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedBooleanArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut NT_Bool,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedBooleanArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedBooleanArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedBooleanArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedBooleanArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedBooleanArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedBooleanArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(len)
        )
    );
}
impl Default for NT_TimestampedBooleanArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetBooleanArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const NT_Bool,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultBooleanArray(
        pubentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetBooleanArray(
        subentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicBooleanArray(
        subentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
        value: *mut NT_TimestampedBooleanArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicBooleanArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedBooleanArray(value: *mut NT_TimestampedBooleanArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueBooleanArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedBooleanArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueBooleanArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueBooleanArray(arr: *mut NT_TimestampedBooleanArray, len: usize);
}
#[doc = " Timestamped IntegerArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedIntegerArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut i64,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedIntegerArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedIntegerArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedIntegerArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedIntegerArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedIntegerArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedIntegerArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(len)
        )
    );
}
impl Default for NT_TimestampedIntegerArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetIntegerArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const i64,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultIntegerArray(
        pubentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetIntegerArray(
        subentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut i64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicIntegerArray(
        subentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
        value: *mut NT_TimestampedIntegerArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicIntegerArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedIntegerArray(value: *mut NT_TimestampedIntegerArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueIntegerArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedIntegerArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueIntegerArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueIntegerArray(arr: *mut NT_TimestampedIntegerArray, len: usize);
}
#[doc = " Timestamped FloatArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedFloatArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut f32,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedFloatArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedFloatArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedFloatArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedFloatArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedFloatArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedFloatArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(len)
        )
    );
}
impl Default for NT_TimestampedFloatArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetFloatArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const f32,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultFloatArray(
        pubentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetFloatArray(
        subentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicFloatArray(
        subentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
        value: *mut NT_TimestampedFloatArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicFloatArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedFloatArray(value: *mut NT_TimestampedFloatArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueFloatArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedFloatArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueFloatArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueFloatArray(arr: *mut NT_TimestampedFloatArray, len: usize);
}
#[doc = " Timestamped DoubleArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedDoubleArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut f64,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedDoubleArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedDoubleArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedDoubleArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedDoubleArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedDoubleArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedDoubleArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(len)
        )
    );
}
impl Default for NT_TimestampedDoubleArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetDoubleArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const f64,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultDoubleArray(
        pubentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetDoubleArray(
        subentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicDoubleArray(
        subentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
        value: *mut NT_TimestampedDoubleArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicDoubleArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedDoubleArray(value: *mut NT_TimestampedDoubleArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueDoubleArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedDoubleArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueDoubleArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueDoubleArray(arr: *mut NT_TimestampedDoubleArray, len: usize);
}
#[doc = " Timestamped StringArray.\n @ingroup ntcore_c_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedStringArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut WPI_String,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedStringArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedStringArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedStringArray>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TimestampedStringArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedStringArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedStringArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(len)
        )
    );
}
impl Default for NT_TimestampedStringArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetStringArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const WPI_String,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultStringArray(
        pubentry: NT_Handle,
        defaultValue: *const WPI_String,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetStringArray(
        subentry: NT_Handle,
        defaultValue: *const WPI_String,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut WPI_String;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicStringArray(
        subentry: NT_Handle,
        defaultValue: *const WPI_String,
        defaultValueLen: usize,
        value: *mut NT_TimestampedStringArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicStringArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedStringArray(value: *mut NT_TimestampedStringArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueStringArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedStringArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueStringArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueStringArray(arr: *mut NT_TimestampedStringArray, len: usize);
}
