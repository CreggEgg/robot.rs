/* automatically generated by rust-bindgen 0.70.1 */

pub type string = [u64; 4usize];
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _c_REVLib_ErrorCode {
    c_REVLibError_None = 0,
    c_REVLibError_General = 1,
    c_REVLibError_CANTimeout = 2,
    c_REVLibError_NotImplemented = 3,
    c_REVLibError_HAL = 4,
    c_REVLibError_CantFindFirmware = 5,
    c_REVLibError_FirmwareTooOld = 6,
    c_REVLibError_FirmwareTooNew = 7,
    c_REVLibError_ParamInvalidID = 8,
    c_REVLibError_ParamMismatchType = 9,
    c_REVLibError_ParamAccessMode = 10,
    c_REVLibError_ParamInvalid = 11,
    c_REVLibError_ParamNotImplementedDeprecated = 12,
    c_REVLibError_FollowConfigMismatch = 13,
    c_REVLibError_Invalid = 14,
    c_REVLibError_SetpointOutOfRange = 15,
    c_REVLibError_Unknown = 16,
    c_REVLibError_CANDisconnected = 17,
    c_REVLibError_DuplicateCANId = 18,
    c_REVLibError_InvalidCANId = 19,
    c_REVLibError_SparkMaxDataPortAlreadyConfiguredDifferently = 20,
    c_REVLibError_SparkFlexBrushedWithoutDock = 21,
    c_REVLibError_NumCodes = 22,
}
pub use self::_c_REVLib_ErrorCode as c_REVLib_ErrorCode;
extern "C" {
    pub fn c_REVLib_SendError(code: c_REVLib_ErrorCode, deviceId: raw::c_int);
}
extern "C" {
    pub fn c_REVLib_SendErrorText(code: c_REVLib_ErrorCode, deviceId: raw::c_int, context: string);
}
extern "C" {
    pub fn c_REVLib_FlushErrors();
}
extern "C" {
    pub fn c_REVLib_SuppressErrors(suppress: bool);
}
extern "C" {
    pub fn c_REVLib_ErrorSize() -> raw::c_int;
}
extern "C" {
    pub fn c_REVLib_ErrorFromCode(code: c_REVLib_ErrorCode) -> *const raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SIM_SparkMax_Obj {
    _unused: [u8; 0],
}
pub type c_SIM_SparkMax_handle = *mut c_SIM_SparkMax_Obj;
extern "C" {
    pub fn c_SIM_SparkMax_Create(deviceId: raw::c_int, sparkModel: u8) -> c_SIM_SparkMax_handle;
}
extern "C" {
    pub fn c_SIM_SparkMax_Destory(handle: c_SIM_SparkMax_handle);
}
extern "C" {
    pub fn c_SIM_SparkMax_IsSim(handle: c_SIM_SparkMax_handle) -> bool;
}
extern "C" {
    pub fn c_SIM_SparkMax_SetParameter(
        handle: c_SIM_SparkMax_handle,
        parameterID: u8,
        type_: u8,
        value: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetParameter(
        handle: c_SIM_SparkMax_handle,
        parameterID: u8,
        type_: u8,
        value: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetFirmwareVersion(handle: c_SIM_SparkMax_handle) -> u32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetAppliedOutput(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetFaults(handle: c_SIM_SparkMax_handle) -> u16;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetInverted(handle: c_SIM_SparkMax_handle) -> u8;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetIsFollower(handle: c_SIM_SparkMax_handle) -> u8;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetStickyFaults(handle: c_SIM_SparkMax_handle) -> u16;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetOutputCurrent(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetBusVoltage(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetMotorTemperature(handle: c_SIM_SparkMax_handle) -> u8;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetVelocity(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetPosition(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetAnalogVoltage(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetAnalogPosition(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetAnalogVelocity(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetAltEncoderPosition(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetAltEncoderVelocity(handle: c_SIM_SparkMax_handle) -> f32;
}
extern "C" {
    pub fn c_SIM_SparkMax_SetAppliedOutput(handle: c_SIM_SparkMax_handle, value: f32);
}
extern "C" {
    pub fn c_SIM_SparkMax_SetAnalogVoltage(handle: c_SIM_SparkMax_handle, value: f32);
}
extern "C" {
    pub fn c_SIM_SparkMax_SetAnalogPosition(handle: c_SIM_SparkMax_handle, value: f32);
}
extern "C" {
    pub fn c_SIM_SparkMax_SetAnalogVelocity(handle: c_SIM_SparkMax_handle, value: f32);
}
extern "C" {
    pub fn c_SIM_SparkMax_SetAltEncoderVelocity(handle: c_SIM_SparkMax_handle, value: f32);
}
extern "C" {
    pub fn c_SIM_SparkMax_SetFollow(
        handle: c_SIM_SparkMax_handle,
        followerArbId: u32,
        followerCfg: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_SetTelemetry(
        handle: c_SIM_SparkMax_handle,
        value: f32,
        apiId: raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_RestoreFactoryDefaults(
        handle: c_SIM_SparkMax_handle,
        persist: bool,
        resetAll: bool,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_SetSetpoint(
        handle: c_SIM_SparkMax_handle,
        value: f32,
        ctrl: u8,
        pidSlot: raw::c_int,
        arbFeedforward: f32,
        arbFFUnits: raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetDRVStatus(
        handle: c_SIM_SparkMax_handle,
        DRVStat0: *mut u16,
        DRVStat1: *mut u16,
        faults: *mut u16,
        stickyFaults: *mut u16,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_ClearFaults(handle: c_SIM_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_SetFreeSpeed(
        handle: c_SIM_SparkMax_handle,
        freeSpeed: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_SetStallTorque(
        handle: c_SIM_SparkMax_handle,
        stallTorque: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetPositionConversionFactor(
        handle: c_SIM_SparkMax_handle,
        factor: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_GetVelocityConversionFactor(
        handle: c_SIM_SparkMax_handle,
        factor: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_SetPositionConversionFactor(
        handle: c_SIM_SparkMax_handle,
        factor: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_SparkMax_SetVelocityConversionFactor(
        handle: c_SIM_SparkMax_handle,
        factor: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SIM_Spark_GetSparkModel(handle: c_SIM_SparkMax_handle) -> u8;
}
extern "C" {
    pub fn c_SIM_Spark_GetMotorInterface(handle: c_SIM_SparkMax_handle) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_Obj {
    _unused: [u8; 0],
}
pub type c_SparkMax_handle = *mut c_SparkMax_Obj;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_APIVersion {
    pub Major: u16,
    pub Minor: u8,
    pub Build: u8,
    pub Version: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_APIVersion"][::std::mem::size_of::<c_SparkMax_APIVersion>() - 8usize];
    ["Alignment of c_SparkMax_APIVersion"]
        [::std::mem::align_of::<c_SparkMax_APIVersion>() - 4usize];
    ["Offset of field: c_SparkMax_APIVersion::Major"]
        [::std::mem::offset_of!(c_SparkMax_APIVersion, Major) - 0usize];
    ["Offset of field: c_SparkMax_APIVersion::Minor"]
        [::std::mem::offset_of!(c_SparkMax_APIVersion, Minor) - 2usize];
    ["Offset of field: c_SparkMax_APIVersion::Build"]
        [::std::mem::offset_of!(c_SparkMax_APIVersion, Build) - 3usize];
    ["Offset of field: c_SparkMax_APIVersion::Version"]
        [::std::mem::offset_of!(c_SparkMax_APIVersion, Version) - 4usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_LimitDirection {
    c_SparkMax_kForward = 0,
    c_SparkMax_kReverse = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_LimitPolarity {
    c_SparkMax_kNormallyOpen = 0,
    c_SparkMax_kNormallyClosed = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_EncoderType {
    c_SparkMax_kNoSensor = 0,
    c_SparkMax_kHallSensor = 1,
    c_SparkMax_kQuadrature = 2,
    c_SparkMax_kSensorless = 3,
    c_SparkMax_kAlternateQuadrature = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_IdleMode {
    c_SparkMax_kCoast = 0,
    c_SparkMax_kBrake = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_SparkModel {
    c_SparkMax_SparkMax = 0,
    c_SparkMax_SparkFlex = 1,
    c_SparkMax_Unknown = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_FaultID {
    c_SparkMax_Fault_kBrownout = 0,
    c_SparkMax_Fault_kOvercurrent = 1,
    c_SparkMax_Fault_kIWDTReset = 2,
    c_SparkMax_Fault_kMotorFault = 3,
    c_SparkMax_Fault_kSensorFault = 4,
    c_SparkMax_Fault_kStall = 5,
    c_SparkMax_Fault_kEEPROMCRC = 6,
    c_SparkMax_Fault_kCANTX = 7,
    c_SparkMax_Fault_kCANRX = 8,
    c_SparkMax_Fault_kHasReset = 9,
    c_SparkMax_Fault_kDRVFault = 10,
    c_SparkMax_Fault_kOtherFault = 11,
    c_SparkMax_Fault_kSoftLimitFwd = 12,
    c_SparkMax_Fault_kSoftLimitRev = 13,
    c_SparkMax_Fault_kHardLimitFwd = 14,
    c_SparkMax_Fault_kHardLimitRev = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_MotorType {
    c_SparkMax_kBrushed = 0,
    c_SparkMax_kBrushless = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_ConfigParameter {
    c_SparkMax_kCanID = 0,
    c_SparkMax_kInputMode = 1,
    c_SparkMax_kMotorType = 2,
    c_SparkMax_kCommAdvance = 3,
    c_SparkMax_kSensorType = 4,
    c_SparkMax_kCtrlType = 5,
    c_SparkMax_kIdleMode = 6,
    c_SparkMax_kInputDeadband = 7,
    c_SparkMax_kFeedbackSensorPID0 = 8,
    c_SparkMax_kFeedbackSensorPID1 = 9,
    c_SparkMax_kPolePairs = 10,
    c_SparkMax_kCurrentChop = 11,
    c_SparkMax_kCurrentChopCycles = 12,
    c_SparkMax_kP_0 = 13,
    c_SparkMax_kI_0 = 14,
    c_SparkMax_kD_0 = 15,
    c_SparkMax_kF_0 = 16,
    c_SparkMax_kIZone_0 = 17,
    c_SparkMax_kDFilter_0 = 18,
    c_SparkMax_kOutputMin_0 = 19,
    c_SparkMax_kOutputMax_0 = 20,
    c_SparkMax_kP_1 = 21,
    c_SparkMax_kI_1 = 22,
    c_SparkMax_kD_1 = 23,
    c_SparkMax_kF_1 = 24,
    c_SparkMax_kIZone_1 = 25,
    c_SparkMax_kDFilter_1 = 26,
    c_SparkMax_kOutputMin_1 = 27,
    c_SparkMax_kOutputMax_1 = 28,
    c_SparkMax_kP_2 = 29,
    c_SparkMax_kI_2 = 30,
    c_SparkMax_kD_2 = 31,
    c_SparkMax_kF_2 = 32,
    c_SparkMax_kIZone_2 = 33,
    c_SparkMax_kDFilter_2 = 34,
    c_SparkMax_kOutputMin_2 = 35,
    c_SparkMax_kOutputMax_2 = 36,
    c_SparkMax_kP_3 = 37,
    c_SparkMax_kI_3 = 38,
    c_SparkMax_kD_3 = 39,
    c_SparkMax_kF_3 = 40,
    c_SparkMax_kIZone_3 = 41,
    c_SparkMax_kDFilter_3 = 42,
    c_SparkMax_kOutputMin_3 = 43,
    c_SparkMax_kOutputMax_3 = 44,
    c_SparkMax_kInverted = 45,
    c_SparkMax_kOutputRatio = 46,
    c_SparkMax_kSerialNumberLow = 47,
    c_SparkMax_kSerialNumberMid = 48,
    c_SparkMax_kSerialNumberHigh = 49,
    c_SparkMax_kLimitSwitchFwdPolarity = 50,
    c_SparkMax_kLimitSwitchRevPolarity = 51,
    c_SparkMax_kHardLimitFwdEn = 52,
    c_SparkMax_kHardLimitRevEn = 53,
    c_SparkMax_kSoftLimitFwdEn = 54,
    c_SparkMax_kSoftLimitRevEn = 55,
    c_SparkMax_kRampRate = 56,
    c_SparkMax_kFollowerID = 57,
    c_SparkMax_kFollowerConfig = 58,
    c_SparkMax_kSmartCurrentStallLimit = 59,
    c_SparkMax_kSmartCurrentFreeLimit = 60,
    c_SparkMax_kSmartCurrentConfig = 61,
    c_SparkMax_kSmartCurrentReserved = 62,
    c_SparkMax_kMotorKv = 63,
    c_SparkMax_kMotorR = 64,
    c_SparkMax_kMotorL = 65,
    c_SparkMax_kMotorRsvd1 = 66,
    c_SparkMax_kMotorRsvd2 = 67,
    c_SparkMax_kMotorRsvd3 = 68,
    c_SparkMax_kEncoderCountsPerRev = 69,
    c_SparkMax_kEncoderAverageDepth = 70,
    c_SparkMax_kEncoderSampleDelta = 71,
    c_SparkMax_kEncoderInverted = 72,
    c_SparkMax_kEncoderRsvd1 = 73,
    c_SparkMax_kVoltageCompMode = 74,
    c_SparkMax_kCompensatedNominalVoltage = 75,
    c_SparkMax_kSmartMotionMaxVelocity_0 = 76,
    c_SparkMax_kSmartMotionMaxAccel_0 = 77,
    c_SparkMax_kSmartMotionMinVelOutput_0 = 78,
    c_SparkMax_kSmartMotionAllowedClosedLoopError_0 = 79,
    c_SparkMax_kSmartMotionAccelStrategy_0 = 80,
    c_SparkMax_kSmartMotionMaxVelocity_1 = 81,
    c_SparkMax_kSmartMotionMaxAccel_1 = 82,
    c_SparkMax_kSmartMotionMinVelOutput_1 = 83,
    c_SparkMax_kSmartMotionAllowedClosedLoopError_1 = 84,
    c_SparkMax_kSmartMotionAccelStrategy_1 = 85,
    c_SparkMax_kSmartMotionMaxVelocity_2 = 86,
    c_SparkMax_kSmartMotionMaxAccel_2 = 87,
    c_SparkMax_kSmartMotionMinVelOutput_2 = 88,
    c_SparkMax_kSmartMotionAllowedClosedLoopError_2 = 89,
    c_SparkMax_kSmartMotionAccelStrategy_2 = 90,
    c_SparkMax_kSmartMotionMaxVelocity_3 = 91,
    c_SparkMax_kSmartMotionMaxAccel_3 = 92,
    c_SparkMax_kSmartMotionMinVelOutput_3 = 93,
    c_SparkMax_kSmartMotionAllowedClosedLoopError_3 = 94,
    c_SparkMax_kSmartMotionAccelStrategy_3 = 95,
    c_SparkMax_kIMaxAccum_0 = 96,
    c_SparkMax_kSlot3Placeholder1_0 = 97,
    c_SparkMax_kSlot3Placeholder2_0 = 98,
    c_SparkMax_kSlot3Placeholder3_0 = 99,
    c_SparkMax_kIMaxAccum_1 = 100,
    c_SparkMax_kSlot3Placeholder1_1 = 101,
    c_SparkMax_kSlot3Placeholder2_1 = 102,
    c_SparkMax_kSlot3Placeholder3_1 = 103,
    c_SparkMax_kIMaxAccum_2 = 104,
    c_SparkMax_kSlot3Placeholder1_2 = 105,
    c_SparkMax_kSlot3Placeholder2_2 = 106,
    c_SparkMax_kSlot3Placeholder3_2 = 107,
    c_SparkMax_kIMaxAccum_3 = 108,
    c_SparkMax_kSlot3Placeholder1_3 = 109,
    c_SparkMax_kSlot3Placeholder2_3 = 110,
    c_SparkMax_kSlot3Placeholder3_3 = 111,
    c_SparkMax_kPositionConversionFactor = 112,
    c_SparkMax_kVelocityConversionFactor = 113,
    c_SparkMax_kClosedLoopRampRate = 114,
    c_SparkMax_kSoftLimitFwd = 115,
    c_SparkMax_kSoftLimitRev = 116,
    c_SparkMax_kSoftLimitRsvd0 = 117,
    c_SparkMax_kSoftLimitRsvd1 = 118,
    c_SparkMax_kAnalogRevPerVolt = 119,
    c_SparkMax_kAnalogRotationsPerVoltSec = 120,
    c_SparkMax_kAnalogAverageDepth = 121,
    c_SparkMax_kAnalogSensorMode = 122,
    c_SparkMax_kAnalogInverted = 123,
    c_SparkMax_kAnalogSampleDelta = 124,
    c_SparkMax_kAnalogRsvd0 = 125,
    c_SparkMax_kAnalogRsvd1 = 126,
    c_SparkMax_kDataPortConfig = 127,
    c_SparkMax_kAltEncoderCountsPerRev = 128,
    c_SparkMax_kAltEncoderAverageDepth = 129,
    c_SparkMax_kAltEncoderSampleDelta = 130,
    c_SparkMax_kAltEncoderInverted = 131,
    c_SparkMax_kAltEncodePositionFactor = 132,
    c_SparkMax_kAltEncoderVelocityFactor = 133,
    c_SparkMax_kAltEncoderRsvd0 = 134,
    c_SparkMax_kAltEncoderRsvd1 = 135,
    c_SparkMax_kHallSensorSampleRate = 136,
    c_SparkMax_kHallSensorAverageDepth = 137,
    c_SparkMax_kNumParameters = 138,
    c_SparkMax_kDutyCyclePositionFactor = 139,
    c_SparkMax_kDutyCycleVelocityFactor = 140,
    c_SparkMax_kDutyCycleInverted = 141,
    c_SparkMax_kDutyCycleSensorMode = 142,
    c_SparkMax_kDutyCycleAverageDepth = 143,
    c_SparkMax_kDutyCycleSampleDelta = 144,
    c_SparkMax_kDutyCycleOffsetv1p6p2 = 145,
    c_SparkMax_kDutyCycleRsvd0 = 146,
    c_SparkMax_kDutyCycleRsvd1 = 147,
    c_SparkMax_kDutyCycleRsvd2 = 148,
    c_SparkMax_kPositionPIDWrapEnable = 149,
    c_SparkMax_kPositionPIDMinInput = 150,
    c_SparkMax_kPositionPIDMaxInput = 151,
    c_SparkMax_kDutyCycleZeroCentered = 152,
    c_SparkMax_kDutyCyclePrescaler = 153,
    c_SparkMax_kDutyCycleOffset = 154,
    c_SparkMax_kProductId = 155,
    c_SparkMax_kDeviceMajorVersion = 156,
    c_SparkMax_kDeviceMinorVersion = 157,
    c_SparkMax_NumParameters = 158,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_PeriodicFrame {
    c_SparkMax_kStatus0 = 0,
    c_SparkMax_kStatus1 = 1,
    c_SparkMax_kStatus2 = 2,
    c_SparkMax_kStatus3 = 3,
    c_SparkMax_kStatus4 = 4,
    c_SparkMax_kStatus5 = 5,
    c_SparkMax_kStatus6 = 6,
    c_SparkMax_kStatus7 = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_ControlType {
    c_SparkMax_kDutyCycle = 0,
    c_SparkMax_kVelocity = 1,
    c_SparkMax_kVoltage = 2,
    c_SparkMax_kPosition = 3,
    c_SparkMax_kSmartMotion = 4,
    c_SparkMax_kCurrent = 5,
    c_SparkMax_kSmartVelocity = 6,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_DataPortConfig {
    c_SparkMax_kDataPortConfigNone = -1,
    c_SparkMax_kDataPortConfigLimitSwitchesAndAbsoluteEncoder = 0,
    c_SparkMax_kDataPortConfigAltEncoder = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus0 {
    pub appliedOutput: f32,
    pub faults: u16,
    pub stickyFaults: u16,
    pub motorType: c_SparkMax_MotorType,
    pub isFollower: u8,
    pub isInverted: u8,
    pub lock: u8,
    pub roboRIO: u8,
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_PeriodicStatus0"]
        [::std::mem::size_of::<c_SparkMax_PeriodicStatus0>() - 24usize];
    ["Alignment of c_SparkMax_PeriodicStatus0"]
        [::std::mem::align_of::<c_SparkMax_PeriodicStatus0>() - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::appliedOutput"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, appliedOutput) - 0usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::faults"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, faults) - 4usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::stickyFaults"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, stickyFaults) - 6usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::motorType"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, motorType) - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::isFollower"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, isFollower) - 12usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::isInverted"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, isInverted) - 13usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::lock"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, lock) - 14usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::roboRIO"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, roboRIO) - 15usize];
    ["Offset of field: c_SparkMax_PeriodicStatus0::timestamp"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus0, timestamp) - 16usize];
};
impl Default for c_SparkMax_PeriodicStatus0 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus1 {
    pub sensorVelocity: f32,
    pub motorTemperature: u8,
    pub busVoltage: f32,
    pub outputCurrent: f32,
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_PeriodicStatus1"]
        [::std::mem::size_of::<c_SparkMax_PeriodicStatus1>() - 24usize];
    ["Alignment of c_SparkMax_PeriodicStatus1"]
        [::std::mem::align_of::<c_SparkMax_PeriodicStatus1>() - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus1::sensorVelocity"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus1, sensorVelocity) - 0usize];
    ["Offset of field: c_SparkMax_PeriodicStatus1::motorTemperature"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus1, motorTemperature) - 4usize];
    ["Offset of field: c_SparkMax_PeriodicStatus1::busVoltage"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus1, busVoltage) - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus1::outputCurrent"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus1, outputCurrent) - 12usize];
    ["Offset of field: c_SparkMax_PeriodicStatus1::timestamp"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus1, timestamp) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus2 {
    pub sensorPosition: f32,
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_PeriodicStatus2"]
        [::std::mem::size_of::<c_SparkMax_PeriodicStatus2>() - 16usize];
    ["Alignment of c_SparkMax_PeriodicStatus2"]
        [::std::mem::align_of::<c_SparkMax_PeriodicStatus2>() - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus2::sensorPosition"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus2, sensorPosition) - 0usize];
    ["Offset of field: c_SparkMax_PeriodicStatus2::timestamp"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus2, timestamp) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus3 {
    pub analogVoltage: f32,
    pub analogVelocity: f32,
    pub analogPosition: f32,
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_PeriodicStatus3"]
        [::std::mem::size_of::<c_SparkMax_PeriodicStatus3>() - 24usize];
    ["Alignment of c_SparkMax_PeriodicStatus3"]
        [::std::mem::align_of::<c_SparkMax_PeriodicStatus3>() - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus3::analogVoltage"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus3, analogVoltage) - 0usize];
    ["Offset of field: c_SparkMax_PeriodicStatus3::analogVelocity"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus3, analogVelocity) - 4usize];
    ["Offset of field: c_SparkMax_PeriodicStatus3::analogPosition"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus3, analogPosition) - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus3::timestamp"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus3, timestamp) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus4 {
    pub altEncoderPosition: f32,
    pub altEncoderVelocity: f32,
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_PeriodicStatus4"]
        [::std::mem::size_of::<c_SparkMax_PeriodicStatus4>() - 16usize];
    ["Alignment of c_SparkMax_PeriodicStatus4"]
        [::std::mem::align_of::<c_SparkMax_PeriodicStatus4>() - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus4::altEncoderPosition"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus4, altEncoderPosition) - 0usize];
    ["Offset of field: c_SparkMax_PeriodicStatus4::altEncoderVelocity"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus4, altEncoderVelocity) - 4usize];
    ["Offset of field: c_SparkMax_PeriodicStatus4::timestamp"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus4, timestamp) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus5 {
    pub dutyCyclePosition: f32,
    pub dutyCycleAbsoluteValue: u8,
    pub dutyCycleStatus: u8,
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_PeriodicStatus5"]
        [::std::mem::size_of::<c_SparkMax_PeriodicStatus5>() - 16usize];
    ["Alignment of c_SparkMax_PeriodicStatus5"]
        [::std::mem::align_of::<c_SparkMax_PeriodicStatus5>() - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus5::dutyCyclePosition"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus5, dutyCyclePosition) - 0usize];
    ["Offset of field: c_SparkMax_PeriodicStatus5::dutyCycleAbsoluteValue"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus5, dutyCycleAbsoluteValue) - 4usize];
    ["Offset of field: c_SparkMax_PeriodicStatus5::dutyCycleStatus"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus5, dutyCycleStatus) - 5usize];
    ["Offset of field: c_SparkMax_PeriodicStatus5::timestamp"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus5, timestamp) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_PeriodicStatus6 {
    pub dutyCycleVelocity: f32,
    pub dutyCycleFrequency: u8,
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_PeriodicStatus6"]
        [::std::mem::size_of::<c_SparkMax_PeriodicStatus6>() - 16usize];
    ["Alignment of c_SparkMax_PeriodicStatus6"]
        [::std::mem::align_of::<c_SparkMax_PeriodicStatus6>() - 8usize];
    ["Offset of field: c_SparkMax_PeriodicStatus6::dutyCycleVelocity"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus6, dutyCycleVelocity) - 0usize];
    ["Offset of field: c_SparkMax_PeriodicStatus6::dutyCycleFrequency"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus6, dutyCycleFrequency) - 4usize];
    ["Offset of field: c_SparkMax_PeriodicStatus6::timestamp"]
        [::std::mem::offset_of!(c_SparkMax_PeriodicStatus6, timestamp) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_FirmwareVersion {
    pub major: u8,
    pub minor: u8,
    pub build: u16,
    pub isDebug: u8,
    pub versionRaw: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_FirmwareVersion"]
        [::std::mem::size_of::<c_SparkMax_FirmwareVersion>() - 12usize];
    ["Alignment of c_SparkMax_FirmwareVersion"]
        [::std::mem::align_of::<c_SparkMax_FirmwareVersion>() - 4usize];
    ["Offset of field: c_SparkMax_FirmwareVersion::major"]
        [::std::mem::offset_of!(c_SparkMax_FirmwareVersion, major) - 0usize];
    ["Offset of field: c_SparkMax_FirmwareVersion::minor"]
        [::std::mem::offset_of!(c_SparkMax_FirmwareVersion, minor) - 1usize];
    ["Offset of field: c_SparkMax_FirmwareVersion::build"]
        [::std::mem::offset_of!(c_SparkMax_FirmwareVersion, build) - 2usize];
    ["Offset of field: c_SparkMax_FirmwareVersion::isDebug"]
        [::std::mem::offset_of!(c_SparkMax_FirmwareVersion, isDebug) - 4usize];
    ["Offset of field: c_SparkMax_FirmwareVersion::versionRaw"]
        [::std::mem::offset_of!(c_SparkMax_FirmwareVersion, versionRaw) - 8usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_AccelStrategy {
    c_SparkMax_kStrategyTrapezoidal = 0,
    c_SparkMax_kStrategySCurve = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_AnalogMode {
    c_SparkMax_kAbsolute = 0,
    c_SparkMax_kRelative = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum c_SparkMax_DutyCycleMode {
    c_SparkMax_kDutyCycleAbsolute = 0,
    c_SparkMax_kDutyCycleRelative = 1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_SparkMax_DRVStatus {
    pub DRVStat0: u16,
    pub DRVStat1: u16,
    pub faults: u16,
    pub stickyFaults: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of c_SparkMax_DRVStatus"][::std::mem::size_of::<c_SparkMax_DRVStatus>() - 8usize];
    ["Alignment of c_SparkMax_DRVStatus"][::std::mem::align_of::<c_SparkMax_DRVStatus>() - 2usize];
    ["Offset of field: c_SparkMax_DRVStatus::DRVStat0"]
        [::std::mem::offset_of!(c_SparkMax_DRVStatus, DRVStat0) - 0usize];
    ["Offset of field: c_SparkMax_DRVStatus::DRVStat1"]
        [::std::mem::offset_of!(c_SparkMax_DRVStatus, DRVStat1) - 2usize];
    ["Offset of field: c_SparkMax_DRVStatus::faults"]
        [::std::mem::offset_of!(c_SparkMax_DRVStatus, faults) - 4usize];
    ["Offset of field: c_SparkMax_DRVStatus::stickyFaults"]
        [::std::mem::offset_of!(c_SparkMax_DRVStatus, stickyFaults) - 6usize];
};
extern "C" {
    pub fn c_SparkMax_RegisterId(deviceId: raw::c_int) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_Create(
        deviceId: raw::c_int,
        type_: c_SparkMax_MotorType,
        unconfirmedModel: c_SparkMax_SparkModel,
        status: *mut c_REVLib_ErrorCode,
    ) -> c_SparkMax_handle;
}
extern "C" {
    pub fn c_SparkMax_Create_Inplace(
        deviceId: raw::c_int,
        unconfirmedModel: c_SparkMax_SparkModel,
        status: *mut c_REVLib_ErrorCode,
    ) -> c_SparkMax_handle;
}
extern "C" {
    pub fn c_SparkMax_Destroy(handle: c_SparkMax_handle);
}
extern "C" {
    pub fn c_SparkMax_CheckId(deviceId: raw::c_int) -> bool;
}
extern "C" {
    pub fn c_SparkMax_GetFirmwareVersion(
        handle: c_SparkMax_handle,
        fwVersion: *mut c_SparkMax_FirmwareVersion,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSerialNumber(
        handle: c_SparkMax_handle,
        serialNumber: *mut [*mut u32; 3usize],
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDeviceId(
        handle: c_SparkMax_handle,
        deviceId: *mut raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetMotorType(
        handle: c_SparkMax_handle,
        type_: c_SparkMax_MotorType,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetMotorType(
        handle: c_SparkMax_handle,
        type_: *mut c_SparkMax_MotorType,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPeriodicFramePeriod(
        handle: c_SparkMax_handle,
        frameId: c_SparkMax_PeriodicFrame,
        periodMs: raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPeriodicFrameTimeout(handle: c_SparkMax_handle, timeoutMs: raw::c_int);
}
extern "C" {
    pub fn c_SparkMax_SetCANMaxRetries(handle: c_SparkMax_handle, numRetries: raw::c_int);
}
extern "C" {
    pub fn c_SparkMax_SetControlFramePeriod(handle: c_SparkMax_handle, periodMs: raw::c_int);
}
extern "C" {
    pub fn c_SparkMax_GetControlFramePeriod(handle: c_SparkMax_handle) -> raw::c_int;
}
extern "C" {
    pub fn c_SparkMax_SetParameterFloat32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetParameterInt32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: i32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetParameterUint32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetParameterBool(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetParameterFloat32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetParameterInt32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: *mut i32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetParameterUint32(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetParameterBool(
        handle: c_SparkMax_handle,
        paramId: c_SparkMax_ConfigParameter,
        value: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus0(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus0,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus1(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus1,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus2(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus2,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus3(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus3,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus4(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus4,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus5(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus5,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPeriodicStatus6(
        handle: c_SparkMax_handle,
        rawframe: *mut c_SparkMax_PeriodicStatus6,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetEncoderPosition(
        handle: c_SparkMax_handle,
        position: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderPosition(
        handle: c_SparkMax_handle,
        position: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_RestoreFactoryDefaults(
        handle: c_SparkMax_handle,
        persist: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_FactoryWipe(handle: c_SparkMax_handle, persist: u8) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetFollow(
        handle: c_SparkMax_handle,
        followerArbId: u32,
        followerCfg: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SafeFloat(f: f32) -> f32;
}
extern "C" {
    pub fn c_SparkMax_SetpointCommand(
        handle: c_SparkMax_handle,
        value: f32,
        ctrl: c_SparkMax_ControlType,
        pidSlot: raw::c_int,
        arbFeedforward: f32,
        arbFFUnits: raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDRVStatus(
        handle: c_SparkMax_handle,
        drvStatus: *mut c_SparkMax_DRVStatus,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetInverted(handle: c_SparkMax_handle, inverted: u8) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetInverted(
        handle: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartCurrentLimit(
        handle: c_SparkMax_handle,
        stallLimit: u8,
        freeLimit: u8,
        limitRPM: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartCurrentLimit(
        handle: c_SparkMax_handle,
        stallLimit: *mut u8,
        freeLimit: *mut u8,
        limitRPM: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSecondaryCurrentLimit(
        handle: c_SparkMax_handle,
        limit: f32,
        chopCycles: raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSecondaryCurrentLimit(
        handle: c_SparkMax_handle,
        limit: *mut f32,
        chopCycles: *mut raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetIdleMode(
        handle: c_SparkMax_handle,
        idlemode: c_SparkMax_IdleMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetIdleMode(
        handle: c_SparkMax_handle,
        idlemode: *mut c_SparkMax_IdleMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSparkModel(
        handle: c_SparkMax_handle,
        model: *mut c_SparkMax_SparkModel,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_EnableVoltageCompensation(
        handle: c_SparkMax_handle,
        nominalVoltage: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetVoltageCompensationNominalVoltage(
        handle: c_SparkMax_handle,
        nominalVoltage: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_DisableVoltageCompensation(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetOpenLoopRampRate(
        handle: c_SparkMax_handle,
        rate: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetOpenLoopRampRate(
        handle: c_SparkMax_handle,
        rate: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetClosedLoopRampRate(
        handle: c_SparkMax_handle,
        rate: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetClosedLoopRampRate(
        handle: c_SparkMax_handle,
        rate: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IsFollower(
        handle: c_SparkMax_handle,
        isFollower: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetFaults(handle: c_SparkMax_handle, faults: *mut u16) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetStickyFaults(
        handle: c_SparkMax_handle,
        stickyFaults: *mut u16,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetFault(
        handle: c_SparkMax_handle,
        faultId: c_SparkMax_FaultID,
        fault: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetStickyFault(
        handle: c_SparkMax_handle,
        faultId: c_SparkMax_FaultID,
        stickyfault: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetBusVoltage(
        handle: c_SparkMax_handle,
        busVoltage: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAppliedOutput(
        handle: c_SparkMax_handle,
        appliedOutput: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimAppliedOutput(handle: c_SparkMax_handle, appliedOutput: f32);
}
extern "C" {
    pub fn c_SparkMax_GetOutputCurrent(
        handle: c_SparkMax_handle,
        outputCurrent: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetMotorTemperature(
        handle: c_SparkMax_handle,
        motorTemperature: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_ClearFaults(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_BurnFlash(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetCANTimeout(
        handle: c_SparkMax_handle,
        timeoutMs: raw::c_int,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_EnableSoftLimit(
        handle: c_SparkMax_handle,
        dir: c_SparkMax_LimitDirection,
        enable: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IsSoftLimitEnabled(
        handle: c_SparkMax_handle,
        dir: c_SparkMax_LimitDirection,
        enabled: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSoftLimit(
        handle: c_SparkMax_handle,
        dir: c_SparkMax_LimitDirection,
        limit: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSoftLimit(
        handle: c_SparkMax_handle,
        dir: c_SparkMax_LimitDirection,
        limit: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSensorType(
        handle: c_SparkMax_handle,
        sensorType: c_SparkMax_EncoderType,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetMotorInterface(
        handle: c_SparkMax_handle,
        motorInterface: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IDQuery(
        uniqueIdArray: *mut u32,
        uniqueIdArraySize: usize,
        numberOfDevices: *mut usize,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IDAssign(uniqueId: u32, deviceId: u8) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_Identify(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IdentifyUniqueId(uniqueId: u32) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetLimitPolarity(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        polarity: c_SparkMax_LimitPolarity,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetLimitPolarity(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        polarity: *mut c_SparkMax_LimitPolarity,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetLimitSwitch(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        limit: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_EnableLimitSwitch(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        enable: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_IsLimitEnabled(
        handle: c_SparkMax_handle,
        sw: c_SparkMax_LimitDirection,
        enabled: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogPosition(
        handle: c_SparkMax_handle,
        position: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogVelocity(
        handle: c_SparkMax_handle,
        velocity: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogVoltage(
        arg1: c_SparkMax_handle,
        voltage: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimAnalogPosition(handle: c_SparkMax_handle, position: f32);
}
extern "C" {
    pub fn c_SparkMax_SetSimAnalogVelocity(handle: c_SparkMax_handle, velocity: f32);
}
extern "C" {
    pub fn c_SparkMax_SetSimAnalogVoltage(arg1: c_SparkMax_handle, voltage: f32);
}
extern "C" {
    pub fn c_SparkMax_SetAnalogPositionConversionFactor(
        arg1: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogVelocityConversionFactor(
        arg1: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogPositionConversionFactor(
        arg1: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogVelocityConversionFactor(
        arg1: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogInverted(
        arg1: c_SparkMax_handle,
        inverted: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogInverted(
        arg1: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogAverageDepth(
        handle: c_SparkMax_handle,
        depth: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAnalogMode(
        handle: c_SparkMax_handle,
        mode: c_SparkMax_AnalogMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAnalogMode(
        handle: c_SparkMax_handle,
        mode: *mut c_SparkMax_AnalogMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetEncoderPosition(
        handle: c_SparkMax_handle,
        position: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetEncoderVelocity(
        handle: c_SparkMax_handle,
        velocity: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPositionConversionFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetVelocityConversionFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPositionConversionFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetVelocityConversionFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAverageDepth(handle: c_SparkMax_handle, depth: u32) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetCountsPerRevolution(
        handle: c_SparkMax_handle,
        cpr: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetCountsPerRevolution(
        handle: c_SparkMax_handle,
        cpr: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetEncoderInverted(
        handle: c_SparkMax_handle,
        inverted: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetEncoderInverted(
        handle: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderPosition(
        handle: c_SparkMax_handle,
        position: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderVelocity(
        handle: c_SparkMax_handle,
        velocity: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimAltEncoderVelocity(handle: c_SparkMax_handle, velocity: f32);
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderPositionFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderVelocityFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderPositionFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderVelocityFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderAverageDepth(
        handle: c_SparkMax_handle,
        depth: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderMeasurementPeriod(
        handle: c_SparkMax_handle,
        samples: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderCountsPerRevolution(
        handle: c_SparkMax_handle,
        cpr: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderCountsPerRevolution(
        handle: c_SparkMax_handle,
        cpr: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetAltEncoderInverted(
        handle: c_SparkMax_handle,
        inverted: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAltEncoderInverted(
        handle: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCyclePosition(
        handle: c_SparkMax_handle,
        position: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleVelocity(
        handle: c_SparkMax_handle,
        velocity: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCyclePositionFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCyclePositionFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleVelocityFactor(
        handle: c_SparkMax_handle,
        conversion: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleVelocityFactor(
        handle: c_SparkMax_handle,
        conversion: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleInverted(
        handle: c_SparkMax_handle,
        inverted: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleInverted(
        handle: c_SparkMax_handle,
        inverted: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleMode(
        handle: c_SparkMax_handle,
        mode: c_SparkMax_DutyCycleMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleMode(
        handle: c_SparkMax_handle,
        mode: *mut c_SparkMax_DutyCycleMode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleAverageDepth(
        handle: c_SparkMax_handle,
        depth: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleSampleDelta(
        handle: c_SparkMax_handle,
        delta: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleSampleDelta(
        handle: c_SparkMax_handle,
        delta: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDutyCycleOffset(
        handle: c_SparkMax_handle,
        offset: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDutyCycleOffset(
        handle: c_SparkMax_handle,
        offset: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetHallSensorSampleRate(
        handle: c_SparkMax_handle,
        sampleRate: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetHallSensorSampleRate(
        handle: c_SparkMax_handle,
        sampleRate: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetHallSensorAverageDepth(
        handle: c_SparkMax_handle,
        depth: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetHallSensorAverageDepth(
        handle: c_SparkMax_handle,
        depth: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_AttemptToSetDataPortConfig(
        handle: c_SparkMax_handle,
        config: c_SparkMax_DataPortConfig,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDataPortConfig(
        handle: c_SparkMax_handle,
        config: *mut c_SparkMax_DataPortConfig,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetP(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetI(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetD(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetDFilter(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetFF(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetIZone(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        IZone: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetOutputRange(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        min: f32,
        max: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetP(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetI(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetD(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetDFilter(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetFF(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        gain: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetIZone(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        IZone: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetOutputMin(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        min: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetOutputMax(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        max: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionMaxVelocity(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        maxVel: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionMaxAccel(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        maxAccel: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionMinOutputVelocity(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        minVel: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionAccelStrategy(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        accelStrategy: c_SparkMax_AccelStrategy,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSmartMotionAllowedClosedLoopError(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        allowedError: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionMaxVelocity(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        maxVel: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionMaxAccel(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        maxAccel: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionMinOutputVelocity(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        minVel: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionAccelStrategy(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        accelStrategy: *mut c_SparkMax_AccelStrategy,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetSmartMotionAllowedClosedLoopError(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        allowedError: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetIMaxAccum(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        iMaxAccum: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetIMaxAccum(
        handle: c_SparkMax_handle,
        slotID: raw::c_int,
        iMaxAccum: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetIAccum(handle: c_SparkMax_handle, iAccum: f32) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetIAccum(handle: c_SparkMax_handle, iAccum: *mut f32) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetFeedbackDevice(
        handle: c_SparkMax_handle,
        sensorID: u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetFeedbackDeviceID(
        handle: c_SparkMax_handle,
        id: *mut u32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetFeedbackDeviceRange(
        handle: c_SparkMax_handle,
        min: f32,
        max: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetAPIVersion() -> c_SparkMax_APIVersion;
}
extern "C" {
    pub fn c_SparkMax_SetLastError(handle: c_SparkMax_handle, error: c_REVLib_ErrorCode);
}
extern "C" {
    pub fn c_SparkMax_GetLastError(handle: c_SparkMax_handle) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GenerateError(
        deviceID: raw::c_int,
        error: c_REVLib_ErrorCode,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimFreeSpeed(
        handle: c_SparkMax_handle,
        freeSpeed: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetSimStallTorque(
        handle: c_SparkMax_handle,
        stallTorque: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPositionPIDWrapEnable(
        handle: c_SparkMax_handle,
        enable: u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPositionPIDMinInput(
        handle: c_SparkMax_handle,
        value: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_SetPositionPIDMaxInput(
        handle: c_SparkMax_handle,
        value: f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPositionPIDWrapEnable(
        handle: c_SparkMax_handle,
        enabled: *mut u8,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPositionPIDMinInput(
        handle: c_SparkMax_handle,
        value: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
extern "C" {
    pub fn c_SparkMax_GetPositionPIDMaxInput(
        handle: c_SparkMax_handle,
        value: *mut f32,
    ) -> c_REVLib_ErrorCode;
}
